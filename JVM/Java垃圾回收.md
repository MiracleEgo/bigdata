# 判断对象是否为垃圾

* 引用计数算法	

  * 通过判断对象的引用数量来决定对象是否可以被回收
  * 每个对象实例都有一个引用计数器，被引用则+1，完成引用则-1
  * 任何引用计数为0的对象实例可以被当作垃圾收集

* 可达性分析算法

  * 通过判断对象的引用链是否可达来决定对象是否可以被回收

    * 可以作为GC Root的对象
      * 虚拟机栈中引用的对象（栈帧中的本地变量表）
      * 方法区中的常量引用的对象
      * 方法区中的类静态属性引用的对象
      * 本地方法栈中JNI的引用对象
      * 活跃线程的引用对象

# 垃圾回收算法

* 标记-清除算法

  * 标记
    * 从根集合进行扫描，对存活的对象进行标记
  * 清除
    * 对堆内存从头到尾进行遍历，回收不可达对象内存

  **不足**

  * 碎片化

* 复制算法（年轻代适用）

  * 分为对象面和空闲面
  * 对象在对象面上创建
  * 存活的对象被从对象面复制到空闲面
  * 将对象面所有对象内存清除

  **优点**

  * 解决碎片化问题
  * 顺序分配内存，简单高效
  * 适用于对象存活率低的场景

* 标记-整理算法

  * 标记
    * 从根集合进行招描，对存活的对象进行标记
  * 清除
    * 移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收

* 分代收集算法

  * 垃圾回收算法的组合拳
  * 按照对象生命周期的不同划分区域以采用不同的垃圾回收算法
  * 目的：提高JVM的回收效率
  * 分类

    * Minor GC
    * Full GC
  * 新生代(1/3)
    * Eden区(8)
    * 两个Survior(1,1)
  * 老年代(2/3)
  * 常用调优参数
    * -XX:SurvivorRatio
      * Eden和Survivor比值,默认8:1
    * -XX:NewRatio
      * 老年代和新生代的内存大小比例
    * -XX:MaxTenuringThreshold
      * 对象从年轻代晋升到老年代经过GC次数的最大阈值

  

# 触发Full GC的条件
* 老年代空间不足
* 永久代(JDK 8已无)空间不足
* CMS GC时出现promotion failed,concurrent mode failure
* Minor GC晋升到老年代的平均大小大于老年代的剩余空间
* 调用System.gc()
* 使用RMI来进行RPC或管理JDK应用,每小时执行一次FullGC

# Stop the World

* JVM 由于要执行GC而停止了应用程序的执行
* 任何一GC算法中都会发生
* 多数GC优化通过减少Stop-the-world发生的时间来提高程序的性能

# 垃圾收集器

* 种类
  * 串行Serial
    * 单线程垃圾回收
  * 并行Parallel
    * 多个垃圾回收线程并行工作
  * 并发标记（CMS）
    * 用户线程与垃圾收集线程同时执行（不一定并行，可交替），不需用户暂停，适用对响应时间有要求的场景
  * G1(java1.9 默认)
    * 将堆内存分割，并发回收，不会产生碎片
    * `-XX:+UseG1GC`,复制+标记-整理算法
    * `stop the world`可控，用户可指定期望时间，增加预测机制
* 查看垃圾收集器
  * `-XX：+printCommandLineFlags -version`

## 年轻代收集器

* Serial收集器
  * `-XX:+UseSerialGC`,复制算法
  * 单线程收集,进行垃圾收集时,必须暂停所有工作线程
  * 简单高效,Client模式下默认的年轻代收集器
* ParNew收集器
  * `-XX:+UseParNewGC`,复制算法
  * 多线程收集器,其余的行为,特点和Serial收集器一样
  * 单核执行效率不如Serial,在多核下执行才有优势
* Parallel Scavenge收集器(1.8默认)
  *  `-XX:+UseParallelGC`,复制算法
  * 吞吐量=运行用户代码时间/(运行用户代码时间+地方都用收集时间)
  * 比起关注用户线程停顿时间,更关注系统的吞吐量
  * 在多核下执行才有优势,Server模式下默认的年轻代收集器

## 老年代收集器

* Serial Old收集器
  * `-XX:+UseSerialOldGC`,标记-整理算法
  * 单线程收集,进行垃圾收集时,必须暂停所有工作线程
  * 简单高效,Client模式下默认的老年代收集器
* Parallel Old收集器(1.8默认)
  * `-XX:+UseParallelOldGC`,标记-整理算法
  * 多线程,吞吐量优先
* CMS收集器
  * `-XX:+UseConcMarkSweepGC`,标记-清除算法
  * 过程
    * 初始标记
      * stop-the-world(很快)
    * 并发标记
      * 并发追溯标记,程序不会停顿
    * 重新标记
      * stop the world
    * 并发清理
      * 清理垃圾对象,程序不会停顿
  * 优点
    * 并发收集停顿低
  * 缺点
    * 会导致大量碎片
    * 对CPU资源压力大


## G1与CMS区别

* G1不会产生内存碎片
* G1可以精确控制停顿，将整个堆划分多个固定大小，根据允许停顿时间收集垃圾最多的区域

# finalize()方法

* Object的protected方法，子类可以覆盖以实现资源清理工作，GC在回收对象之前调用该方法
* 可用来清理本地对象JNI
* 确保某非内存资源释放的一个补充，在finalize方法中显示调用其他资源释放方法
* 对象再生
  * 将待回收对象赋值给GC Roots可达的对象引用，从而达到再生
* 至多由GC执行一次

# 强引用/软引用/弱引用/虚引用

* 强引用

  * 最普遍的引用
    * `Object obj = new Object()`
  * 抛出OutOfMemoryError终止程序也不会回收具有强引用的对象
  * 通过将对象是设置为null来弱化引用,使其被回收

* 软引用

    * 对象处在有用但非必须的状态

    * 只有当内存空间不足时,GC会回收该内存

    * 可以用来实现高速缓存

      ```java
      String str = new String("abc") //强引用
      SoftReference<String> softRef = new SoftReference<String>(str); //软引用
      ```

* 弱引用

  * 非必须的引用,比软引用更弱一些

  * GC时会被回收

  * 被回收的概率也不大,因为GC线程优先级比较低

  * 适用于引用偶尔被使用且不影响垃圾收集的对象

    ```java
    String str = new String("abc");
    WeakReference<String> abcWeakRef = new WeakReference<String>(str)
    ```

* 虚引用

  * 不会决定对象的生命周期
  * 任何时候都可能被垃圾收集器回收
  * 跟踪对象被垃圾收集器回收的活动,起哨兵作用
  * 必须和引用队列ReferenceQueue联合使用,被回收时对象将被放到引用队列中保存

  ```java
  String str = new String("abc");
  ReferenceQueue queue = new ReferenceQueue();
  PhantomReference ref = new PhantomReference(str,queue);
  ```

  | 引用类型 | 被垃圾回收时间 | 用途           | 生存时间          |
  | -------- | -------------- | -------------- | ----------------- |
  | 强引用   | 从来不会       | 对象的一般状态 | JVM停止运行时终止 |
  | 软引用   | 在内存不足时   | 对象缓存       | 内存不足时终止    |
  | 弱引用   | 在垃圾回收时   | 对象缓存       | gc运行后终止      |
  | 虚引用   | Unknow         | 标记,哨兵      | Unknown           |

  