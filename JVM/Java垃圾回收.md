# 判断对象是否为垃圾的算法

* 引用计数算法	

  * 通过判断对象的引用数量来决定对象是否可以被回收
  * 每个对象实例都有一个引用计数器，被引用则+1，完成引用则-1
  * 任何引用计数为0的对象实例可以被当作垃圾收集

* 可达性分析算法

  * 通过判断对象的引用链是否可达来决定对象是否可以被回收

    * 可以作为GC Root的对象
      * 虚拟机栈中引用的对象（栈帧中的本地变量表）
      * 方法区中的常量引用的对象
      * 方法区中的类静态属性引用的对象
      * 本地方法栈中JNI的引用对象
      * 活跃线程的引用对象

# 垃圾回收算法

* 标记-清除算法

  * 标记
    * 从根集合进行扫描，对存活的对象进行标记
  * 清除
    * 对堆内存从头到尾进行遍历，回收不可达对象内存

  **不足**

  * 碎片化

* 复制算法（年轻代适用）

  * 分为对象面和空闲面
  * 对象在对象面上创建
  * 存活的对象被从对象面复制到空闲面
  * 将对象面所有对象内存清除

  **优点**

  * 解决碎片化问题
  * 顺序分配内存，简单高效
  * 适用于对象存活率低的场景

* 标记-整理算法

  * 标记
    * 从根集合进行招描，对存活的对象进行标记
  * 清除
    * 移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收

* 分代收集算法

  * 垃圾回收算法的组合拳
  * 按照对象生命周期的不同划分区域以采用不同的垃圾回收算法
  * 目的：提高JVM的回收效率
  * 分类

    * Minor GC
    * Full GC
  * 新生代(1/3)
    * Eden区(8)
    * 两个Survior(1,1)
  * 老年代(2/3)
  * 常用调优参数
    * -XX:SurvivorRatio
      * Eden和Survivor比值,默认8:1
    * -XX:NewRatio
      * 老年代和新生代的内存大小比例
    * -XX:MaxTenuringThreshold
      * 对象从年轻代晋升到老年代经过GC次数的最大阈值

  

# 触发Full GC的条件
* 老年代空间不足
* 永久代(JDK 8已无)空间不足
* CMS GC时出现promotion failed,concurrent mode failure
* Minor GC晋升到老年代的平均大小大于老年代的剩余空间
* 调用System.gc()
* 使用RMI来进行RPC或管理JDK应用,每小时执行一次FullGC

# Stop-the-World

* JVM 由于要执行GC而停止了应用程序的执行
* 任何一GC算法中都会发生
* 多数GC优化通过减少Stop-the-world发生的时间来提高程序的性能

# SafePoint

* 分析过程中对象引用关系不会了生变化的点
* 产生Safepoint的地方
  * 方法调用
  * 循环跳转
  * 异常跳转
* 安全点数量得适中

# 常见的垃圾收集器

## JVM的运行模式

* Server
* Client

## 垃圾收集器

## 年轻代收集器

Serial收集器

* -XX:+UseSerialGC,复制算法

* 单线程收集,进行垃圾收集时,必须暂停所有工作线程
* 简单高效,Client模式下默认的年轻代收集器

ParNew收集器

* -XX:+UseParNewGC,复制算法
* 多线程收集器,其余的行为,特点和Serial收集器一样
* 单核执行效率不如Serial,在多核下执行才有优势

Parallel Scavenge收集器(1.8默认)

*  -XX:+UseParallelGC,复制算法
* 吞吐量=运行用户代码时间/(运行用户代码时间+地方都用收集时间)
* 比起关注用户线程停顿时间,更关注系统的吞吐量
* 在多核下执行才有优势,Server模式下默认的年轻代收集器

## 老年代收集器

Serial Old收集器

* -XX:+UseSerialOldGC,标记-整理算法
* 单线程收集,进行垃圾收集时,必须暂停所有工作线程
* 简单高效,Client模式下默认的老年代收集器

Parallel Old收集器(1.8默认)

* -XX:+UseParallelOldGC,标记-整理算法
* 多线程,吞吐量优先

CMS收集器

* -XX:+UseConcMarkSweepGC,标记-清除算法
* 初始标记:stop-the-world(很快)
* 并发标记
  * 并发追溯标记,程序不会停顿
* 并发预清理
  * 查找执行并发标记阶段从年轻代晋升到老年代的对象
* 重新标记
  * 暂停虚拟机,扫描CMS堆中的剩余对象
* 并发清理
  * 清理垃圾对象,程序不会停顿
* 并发重围
  * 重置CMS收集器的数据结构

G1收集器

* -XX:+UseG1GC,复制+标记-整理算法
* 并行和并发
* 分代收集
* 空间整合
* 可预测停顿
* 将整个Java堆内存划分成多个大小相等的Region
* 年轻代和老年代不再物理隔离

# Object的finalize()方法的作用是否与C++的析构函数作用相同?

* 不同,析构函数调用确定,而它是不确定的
* 将未被引用的对象放置于F-Queue队列
* 方法执行随时可能会被终止
* 给予对象一次重生机会

# Java中的强引用,软引用,弱引用,虚引用有什么用?

* 强引用

  * 最普遍的引用
    * Object obj = new Object()
  * 抛出OutOfMemoryError终止程序也不会回收具有强引用的对象
  * 通过将对象是设置为null来弱化引用,使其被回收

* 软引用

    * 对象处在有用但非必须的状态

    * 只有当内存空间不足时,GC会回收该引用的对象的内存

    * 可以用来实现高速缓存

      ```java
      String str = new String("abc") //强引用
      SoftReference<String> sofeRef = new SoftReference<String>(str); //软引用
      ```

* 弱引用

  * 非必须的引用,比软引用更弱一些

  * GC时会被回收

  * 被回收的概率也不大,因为GC线程优先级比较低

  * 适用于引用偶尔被使用且不影响垃圾收集的对象

    ```java
    String str = new String("abc");
    WeakReference<String> abcWeakRef = new WeakReference<String>(str)
    ```

* 虚引用

  * 不会决定对象的生命周期
  * 任何时候都可能被垃圾收集器回收
  * 跟踪对象被垃圾收集器回收的活动,起哨兵作用
  * 必须和引用队列ReferenceQueue联合使用

  ```java
  String str = new String("abc");
  ReferenceQueue queue = new ReferenceQueue();
  PhantomReference ref = new PhantomReference(str,queue);
  ```

  | 引用类型 | 被垃圾回收时间 | 用途           | 生存时间          |
  | -------- | -------------- | -------------- | ----------------- |
  | 强引用   | 从来不会       | 对象的一般状态 | JVM停止运行时终止 |
  | 软引用   | 在内存不足时   | 对象缓存       | 内存不足时终止    |
  | 弱引用   | 在垃圾回收时   | 对象缓存       | gc运行后终止      |
  | 虚引用   | Unknow         | 标记,哨兵      | Unknown           |

  