# Redis与Memcache的区别

* Memchache多线程，Redis单进程单线程
* Redis支持集群
* Redis数据类型丰富

# 为何Redis单线程这么快

* 纯内存操作
* 非阻塞的IO多路复用
* 单线程避免频繁上下文切换

# Redis单进程单线程模型

- 内存采用的是单进程单线程模型的KV数据库，QPS(每秒内查询次数) 10w
- Redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。
- 多线程处理会涉及到锁，而且多线程处理会涉及到线程切换而消耗CPU。因为CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存或者网络带宽。单线程无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来解决。

# 多路I/O复用模型

* 通过一种机制，一个进程监视多个描述符，一旦某个描述符就绪（一般读或写就绪），能够通知程序进行相应的读写操作

* 利用select,poll,epoll可以同时监察多个流的I/O事件的能力，本质都是同步IO，读写过程阻塞

* 在空闲时，会把当前线程阻塞，当有一个或多个流有I/O事件时，就从阻塞态唤醒，于是程序就会轮询一遍所有的流（epoll是只轮询真正了出了事件的流），且依次顺序处理就绪的流，避免大量无用操作

* 多路

  * 多个网络连接

* 复用
  * 复用同一个进程

* 优势

  * 采用多路复用技术可以让单个线程高效处理多个连接请求，（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快，即内存内的操作不会成为影响Redis性能的瓶颈
  * 系统开销小，系统不必创建进程/线程，也不必维护这些线程，大大减小了系统开销

  

# Redis特性

- 速度快
  - 因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
- 支持丰富数据类型
  - 支持string，list，set，sorted set，hash
- 支持事务
  - 操作都是原子性
- 丰富的特性
  - 可用于缓存，消息，按key设置过期时间，过期后将会自动删除


# Redis支持的数据类型

* string：最基本的数据类型，二进制安全的字符串，最大512M。
* list：按照添加顺序保持顺序的字符串列表。
* set：无序的字符串集合，不存在重复的元素。
* sorted set：已排序的字符串集合。
* Hash：key-value对的一种集合。

![img](https://pic1.zhimg.com/80/v2-9f60b2278b9cedc0aaae7c22d2a02b34_hd.jpg)

# String实现原理

* redis键值对中的key都是string类型的，redis底层是用C写的，对于String并没有直接使用C的字符数组，而是自己封装了一个sds类型

![img](https://img-blog.csdn.net/20170816140922843?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDkwMDc1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

* 为何需要新建数据类型？

  * C的字符串api是不安全，顺为在使用字符数组后，需要跟踪内存的分配，在使用之前，需要预分配内存空间，否则会有缓冲区溢出，用完一个字符串，需要回收，否则会有内存泄漏
  * 将分配内存的事封装，不让调用方得知-->sds作用
  * 空间预分配，惰性回收
    * 每创建 一个新的String，不按实际大小分配，而是预分配更多内存。当字符串截断时，也不是立刻回收内存，而是减少len值，增加free值。字符串插入时，先看free够不够，不够再分配。这样减少了内存分配回收次数

* SDS与C字符串的区别

  ![img](https://img-blog.csdn.net/20170816141720909)

* SDS好处

  * 获取长度O（1）
  * 杜绝缓冲区溢出
  * 减少了字符串改变造成的空间分配次数

# 从海量Key里查询某一固定前缀的Key

**使用keys对线上的业务的影响**

  * KEYS pattern

    `keys k1*`

    * 查询所有符合给定模式pattern的key

    * KEYS指令一次性返回所有匹配的key

    * 键的数量过大会造成服务器卡顿

* SCAN cursor

   `scan 0 match k1* count 10  `  

   *  基于游标的迭代器,需要基于上一次的游标延续之前的迭代过程
   *  以0作为粮票开始一次新的迭代,直到命令返回游标0完成一次遍历
   *  不保证每次执行都返回某个给定数量的元素,支持模糊查询
   *  一次返回的数量不可控.只能是大概率符合count参数

# Redis 怎么实现分布式锁？

* 分布式锁需要解决的问题
  * 互斥性
  * 安全性
  * 死锁
  * 容错
* `SETNX key value`
  * 如果key不存在,则创建并赋值
  * 时间复杂度O(1)
  * 返回值
    * 设置成功,返回1;设置失败,返回0
    * 即如果设置成功,则没有其他线程执行该代码

## 如何解决SETNX长期有效的问题?

* `EXPIRE key seconds`
  * 设置key的生存时间.当key过期时(生存时间为0),会被自动删除

* 缺点

  * 原子性得不到满足,如果设置好setnx后,程序挂掉,来不及设置过期时间,则该资源得不到释放

## 最终分布式锁实现方案

```bash
SET key value [EX seconds] [PX milliseconds] [NX|XX]
```

* 参数

  * EX second 

    * 设置键的过期时间为second秒

  * PX millisecond

    * 设置键的过期时间为millisecond 毫秒

  * NX

    * 只在键不存在时,才对键进行设置操作

  * XX

    * 只在键已经存在时,才对键进行设置操作

  * SET操作成功完成时,返回OK,否则返回nil

> set locktarget 12345 ex 10 nx

* 要点

  * value要具有唯一性
  * 释放锁时要验证value值,不能误解锁

* 缺点

  * 加锁时只作用在一个Redis节点上

  * 如果这个master节点发生了主从切换,那么会有锁丢失的情况

    * 在Redis的master节点上拿到了锁,但这个加锁的ke还没有同步到slave节点
    * master故障,发生故障转移,slave节点升级为master节点,导致锁丢失

# Key删除策略

* 定期删除
  * 默认每隔100ms随机抽取设置过过期时间的key，若过期则删除
* 惰性删除
  * 当获取某key时，检查是否过期，过期删除且不返回任何东西

## 大量的key同时过期的注意事项

* 集中过期, 由于清除大量的key很耗时,会出现短暂的卡顿现象
* 解决
  * 在设置key过期时间的时候,给每个key的过期时间加上随机值,使时间分散

## 内存淘汰策略

* volatile-lru 
  * 从设置过期时间的数据集中挑选出最近最少使用
* volatile-ttl
  * 从设置过期时间数据中选将要过期数据
* volatile-random
  * 从已设置过期时间数据中选任意数据
* allkeys-lru
  * 从所有数据集中选最近最少使用
* allkeys-random
  * 从所有数据集中任意选数据
* noeviction
  * 禁止驱逐数据

# 如何使用Redis做异步队列?

* **使用List作为队列,RPUSH生产消息,LPOP消费消息**
  * 缺点
    * 没有等待队列里有值就直接消费
  * 弥补
    * 可以通过在应用层引用Sleep机制去调用LPOP重试

* `BLPOP key [key ...] timeout` :阻塞直到队列有消息或者超时

  ```redis
  blpop testlist 30   //30秒内一直等待
  ```

  * 缺点
    * 只能供一个消费者消费

* pub/sub:主题订阅者模式

  * 发送者(pub)发送消息,订阅者(sub接收消息)

  * 订阅者可以订阅任意数量的频道(topic)

    * `publish myTopic "Hello"`

    * `subscribe myTopic`

  * 缺点

    * 消息的发布是无状态的,无法保证可达

# Redis如何做持久化

* RDB(快照)持久化
  * 保存某个时间点的全量数据快照
  * SAVE
    * 阻塞Redis的服务进程,直到RDB文件被创建完毕
  * BGSAVE
    * Fork出一个子进程来创建RDB文件,不阻塞服务器进程
  * 缺点
    * 内存数据的全量同步,数据量大会由于I/O而严重影响性能
    * 可能会因为Redis挂掉而丢失从当前至最近一次快照期间的数据
  * 自动触发RDB持久化的方式
    * 根据redis.conf配置里的SAVE m n 定时触发(用的是BGSAVE)
    * 主从复制时,主节点自动触发
    * 执行Debug Reload
    * 执行Shutdown且没有开启AOF
* AOF(Append-Only-File)持久化:保存写状态
  * 记录下除了查询以外的所有变更数据库状态的指令
  * 以append的形式追加保存到AOF文件(增量)
* RDB-AOF混合持久化方式
  * BGSAVE做镜像全量持久化,AOF做增量持久化

## 日志重写解决AOF文件大小不断增大的问题

* AOF重写机制
  * 调用fork(),创建一个子进程(重写子进程)
  * 子进程读取现有AOF文件,将指令分析压缩并写入临时文件中
  * 主进程持续将新的变动同时写到内存和原来的AOF里,以保证原有AOF可用性
  * 主进程获取子进程重写AOF的完成信号,往新AOF同步增量变动
  * 使用新的AOF文件替换掉旧的AOF文件



# Redis一致性哈希算法

* 在传统的哈希表中，添加或删除一个槽位，几乎需要对所有关键字进行重新映射
  * 算法使用节点数取余，强依赖node数，当node数发生变化时，数据需要迁移
* 一致性Hash将整个hash值空间组织成一个虚拟的圆环（2^32）
* 将服务器使用Hash（ip或主机名为关键字）进行哈希，确定在环上的位置
* 将数据key使用相同的函数hash计算出哈希值，并确定此数据在环上的位置，从此位置顺时针走，遇到第一台服务器，就是其位置
* 不足
  * 在服务结点太少时，容易因节点分布不均而造成数据倾斜
* 解决
  * 引入虚节点，对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点
  * 数据定位算法不变，只是多了虚节点到实际结点的映射
  * 在实际应用中，通常将虚节点数设置为32甚至更大

# Redis数据的恢复

RDB和AOF文件共存情况下的恢复流程

* 检查是否有AOF文件
  * 若存在,则使用AOF文件
  * 否则,使用RDB文件

RDB和AOF的优缺点

* RDB优点
  * 全量数据快照,文件小,恢复快
* RDB缺点
  * 无法保存最近一次快照之后的数据
* AOF优点
  * 可读性高,适合保存增量数据,数据不易丢失
* AOF缺点
  * 文件体积大,恢复时间长

# Redis的同步机制

* 全同步过程
  * Slave发送sync命令到Master
  * Master启动一个后台进程,将Redis中的数据快照保存到文件中
  * Master将保存数据快照期间接收到的写命令缓存起来
  * Master完成写文件操作后,将该文件发送给Slave
  * 使用新的AOF文件替换旧的AOF文件
  * Master 将这期间收集的增量写命令发送给Slave端
* 增量同步过程
  * Master接收到用户的操作指令,判断是否需要传播到Slave
  * 将操作记录追加到AOF文件
  * 将操作传播到其他Slave
    * 对齐主从库
    * 往响应缓存写入指令
  * 将缓存中的数据发送给Slave

# 缓存雪崩

* 缓存挂后大量数据请求落在数据库，导致数据库挂掉
* 缓解
  * 事前
    * 保证redis高可用
  * 事中
    * 在系统内部增加ehcache缓存，系统先在ehcache查找数据，再去redis
    * 通过Hystrix限流，限制请求通达数量
  * 事后
    * redis持久化机制，redis恢复时从磁盘恢复数据

# 缓存穿透

* 恶意攻击，数据库中无请求数据，缓存中也无请求数据
* 解决
  * 将未查到的请求写一个空值到Redis中

# 如何保证缓存和数据库一致性

* 先删除缓存，再更新数据库







