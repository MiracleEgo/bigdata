# MySQL索引原理和优化

## MySQL索引原理

### 哈希索引

* 利用Hash存储的话需要将所有的数据文件添加到内存，比较耗费内存空间
* 如果所有的查询都是等值查询，hash确实很快，实际应用中范围查找数据的场景多

### InnoDB引擎

* 索引组织表

### MYISAM引擎

* 堆表

### 主键索引和二级索引

* 回表包含二级索引(SecondaryIndex)的查询，回到主键索引(PK)进行数据查找的过程叫做回表

* 每一次索引上的查询都对应数据库的一次IO操作

* 主键会出现在所有聚簇索引上和二级索引上所以尺寸要小数据也(Page)的大小是固定的，每个字段占用的空间越少，每个page就可以存放尽量多的行

* 写入时，主键最好有序，否则容易造成页面分裂，引起额外的IO操作

* 推荐使用没有业务意义的自增主键，举例：

  >  id INT(11) **unsigned** NOT NULL AUTO_INCREMENT COMMENT '主键id’
  >
  > unsigined将会过滤掉负值

## 索引优化原则

* 查询 `SELECT * FROM demo WHERE number = 10`
  * UK_number（number上有唯一索引）
    * 二级索引上搜索到number=10，去主键上取数据，返回
  * IX_number（number上有非唯一索引）
  * 二级索引上搜索到number=10，去主键上取数据，返回，判断下一个值是不是10
* 更新 `INSERT INTO demo(number) SELECT 10`
  * UK_number（number上有唯一索引）
    * 数据在内存里，判断唯一性，写入值
    * 数据不在内存里，读入内存，判断唯一性，写入值，结束
  * IX_number（number上有非唯一索引）
    * 数据在内存里，写入值
    * 数据不在内存时需，读入内存，写入值，写入change buffer，结束

* 二级索引中，普通索引和唯一索引怎么选？

  * 归档业务

    * 非唯一索引优于唯一索引
  * 写完就查的业务
* 唯一索引优于非唯一索引
* 大多数情况下，一个简单的SQL只能用到一个索引
* 业务逻辑中用到的SQL尽可能通过索引的方式访问数据，是否用到索引，可以通过EXPLAIN判断
* 特殊意义的字段，建议加上索引
  * create_time：记录创建时间
  * update_time：记录修改时间
* 慢查询中的SQL，先判断是否可以通过添加索引或者调整索引结构解决
* 如何建立合适的索引？
  * 区分度较高的列
  * 尽量使用字段长度小的列作为索引
  * 造作NOT NULL的列
    * 含有空值的列很难进行查询优化
  * 尽量扩展索引，不要新建索引
* 防止隐式转换
* 如何用好索引
  * 禁止在where条件的列名上使用函数
  * 禁止使用存储过程、存储函数、触发器和视图
  * 尽量不要在数据库里做运算
  * 尽量不要做%前缀模糊查询，如like '%name'
  * 不要使用大领衔量的limit分页
  * update/delete尽量根据主键进行操作

## 索引优化案例

