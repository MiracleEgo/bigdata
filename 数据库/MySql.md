# MySQL 索引

* 索引的原理

  * 对要查询的字段建立索引==>**把该字段按照一定的方式排序**；
  * 建立的索引只对该字段有用，若查询其他字段,则索引无效
  * 索引太多会降低查询的速度
* 优点

  * 查询时就会先去索引列表中一次定位到特定值的行数大大减少遍历匹配的行数，增加查询的速度。
* 缺点
  * 全表查询情况,索引无意义
  * 对非唯一的字段，例如“性别”这种大量重复值的字段，增加索引也没有什么意义。
  * 索引是需要存储空间, 对于记录比较少的表，增加索引不会带来速度的优化反而浪费了存储空间，
  * 对于update/insert/delete的每次执行，字段的索引都必须重新计算更新。所以并不是任何情况下都改建立索引的

## **哪些列适合建立索引**

* 经常需要搜索的列
* 在**作为主键的列**上，强制该列的唯一性和组织表中数据的排列结构。
* 经常用在连接的列上，这些列主要是**外键**，**可以加快连接速度。** 
* 经常需要**根据范围进行搜索的列**上创建索引，因为索引已经排序，所以其指定的范围是连续的。
* 经常需要排列的列，因为索引已经排序，这样可以利用索引的排序，**加快查询的速度。** 
* **经常需要使用WHERE子句**，**加快条件的判断速度。**

## MySQL里的索引类型

* B-Tree索引

  * 最常见的索引类型，基于B-Tree数据结构
  * B-Tree的基本思想是，所有值（被索引的列）都是排过序的，每个叶节点到跟节点距离相等。
  * B-Tree适合用来查找某一范围内的数据，而且可以直接支持数据排序（ORDER BY）。但是当索引多列时，列的顺序特别重要，需要格外注意。
  * InnoDB和MyISAM都支持B-Tree索引。
* B+树索引
  * InnoDB默认使用
  * MyISAM为了节省空间对索引进行了压缩,从而牺牲了性能
* Hash索引
  * 基于hash表。只支持精确查找，不支持范围查找，不支持排序。
  * Hash索引与B+树索引的区别
    - Hash索引适合等值查询,但无法进行范围查询
    - Hash索引无法完成排序,不支持多列联合索引的最左匹配原则
    - 如果有大量重担键值的情况下,效率很低,因存在Hash碰撞
* 全文索引`Full-Text`
  * MySQL5.6及以后，MyISAM和InnoDB都支持
* 空间数据索引`R-Tree`
  * MyISAM支持，可用于地理数据存储

## 索引下推

* 在MySQL5.6之后,对索引的优化
* 可以在有like条件查询的情况下,减少回表次数

## [为何使用B+树为索引](https://segmentfault.com/a/1190000004690721)

* B树
  * B树叶子和非叶节点都会保存数据，导致在非叶子节点保存的指针数量变少，指针少的情况下要保存大量数据，只能增加树高，**导致IO操作变多**，查询性能变低
  * B树在提高IO性能的同时并没有解决元素遍历效率低下的问题
  * 每个节点Key和Data在一起,无法区间查询
  * ![clip_image002](https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232634472-395289491.png)

* B+树

  * 只要去遍历叶子结点就可以实现整棵树的遍历

  * 更适合外部存储,由于内节点无data域,一个结点可存储更多的内结点,每个节点能索引的范围更大更精确,意味着B+树单次磁盘IO的信息量大于B树,IO效率更高

  * MySQL是一种关系型数据库,区间访问蝇一种常见的情况,B+树叶子节点有指针,可以用于范围查询

    

# InnoDB

* 若一个主键被定义，该主键则作为密集索引;若没有主键被定义，该表的第一个唯一非空索引则作为密集索引;若不满足以上条件，innodb内部会生成一个隐藏主键（密集索引）
* 索引和数据存在一块,默认为B+树
* 有且只有一个密集索引
* 支持事务
* 当某个索引值被使用非常频繁时，会在B+树索引上创建一个哈希索引

# MyISAM

* 索引和数据分开存储
* 不管是主键索引，唯一键索引还是普通索引都是稀疏索引
* 不支持事务

# [MyISAM与InnoDB区别](https://segmentfault.com/q/1010000011454565)

* 事务
  * MyISAM不支持事务，执行速度快，MyISAM读性能强
  * InnoDB支持事务与外键与行锁
  * InnoDB不保存具体行数，MyISAM可保存好行数读出即可
* 索引
  * MyISAM
    * MyISAM索引和数据分开且索引有压缩，内存使用率提高不少
      * 通过索引直接找到叶子节点中指向具体表中的数据的那个指针
  * InnoDB
  	* InnoDB索引与数据存在一地块
  	* 有聚簇索引,索引数据时需要在二级索引中找到主键,后根据主键到聚簇索引中找到最终数据,需要走两次索引
  	* InnoDB不支持全文索引(5.6版本以后支持)

# .frm .MYD .MYI .idb .par

* 有数据库a,表格b
  * 若表格b采用MyISAM,data\a中会产生3个文件
    * `b.frm`  描述表结构文件,字段长度
    * `b.MYD(MYData)`数据信息文件
    * `b.MYI(MYIndex)`索引信息文件
  * 若表格采用InnoDB,data\a中会产生1个或2个文件
    * `b.frm`描述表结构文件,字段长度
    * `b.idb`存储数据信息和索引信息
  * 若采用分区存储,data\a中还会有一个`b.par`文件,存储分区信息

# MySQL 查询优化

<https://segmentfault.com/a/1190000011330649#articleHeader5>

* MySQL逻辑架构

  ![img](http://dbaplus.cn/uploadfile/2017/0928/20170928110355446.png)

  * 客户端层
    * 并非MySQL所独有
    * 连接处理
    * 授权认证
    * 安全
  * 核心服务
    * 查询解析
    * 分析
    * 优化
    * 缓存
    * 内置函数
  * 存储引擎
    * 数据存储
    * 数据提取

* MySQL查询过程

  ![img](http://dbaplus.cn/uploadfile/2017/0928/20170928110411496.jpg)

  - 客户端向MySQL服务器发送一条查询请求
  - 服务器首先检查查询缓存，如果命中缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段
  - 服务器进行SQL解析、预处理、再由优化器生成对应的执行计划
  - MySQL根据执行计划，调用存储引擎的API来执行查询
  - 将结果返回给客户端，同时缓存查询结果

* 避免向数据库请求不需要的数据

  * 使用LIMIT
  * 避免使用select *

* 查询数据的方式

  * 通过EXPLAIN语句中的type列反应查询的是哪种方式
  * 通过添加合适的索引改善查询数据的方式,使其尽可能减少扫描的数据行,加快查询速度

* 分解大的查询

  * 将大查询分解为多个小查询,每个小查询只完成整个查询任务的一小部分,每次只返回一小部分结果
  * 优点:
    * 缓存效率高
    * 减少锁竞争
    * 更容易对数据库进行拆分,更容易做到高性能和可扩展
    * 查询本身的效率也可能有提升

* 优化MIN()和MAX()

  * 添加索引,B-Tree

* 用IN() 取代OR

  * IN()先将自己列表中折数据进行排序,然后通过二分查找的方式确定列的值是是否在IN()的列表中,时间复杂度O(logn)

  * OR操作,时间复杂度为O(n)

* 优化关联查询

  在MySql中，任何一个查询都可以看成是一个关联查询，即使只有一个表的查询也是如此。
  MySql对任何关联都执行嵌套循环的关联操作，例如对于下面的SQL语句：

  ```sql
  SELECT tbl1.col1,tbl2.col2
  FROM tbl1 INNER JOIN tbl2 USING(col3)
  WHERE tbl1.col1 IN(5,6);
  ```

  下面的伪代码表示MySql将如何执行这个查询：

  ```c
  //先从第一个表中取出符合条件的所有行
  out_iter = iterator over tbl1 where col1 IN(5,6)
  outer_row = out_iter.next
  //在while循环中遍历第一个表结果集的每一行
  while outer_row
      //对于第一个表结果集中的每一行，在第二个表中找出符合条件的所有行
      inner_iter = iterator over tbl2 where col3 = outer_row.col3
      inner_row = inner_iter.next
      while inner_row
          //将第一个表的结果列和第二个表的结果列拼装在一起作为结果输出
          output[outer_row.col1, inner_row.col2]
          inner_row = inner_iter.next
      end
      //回溯，再根据第一个表结果集的下一行，继续上面的过程
      outer_row = outer_iter.next
  end
  ```

  * 通常只需要在关联顺序的第二个表的相应列上创建索引
  * 确保任何的GROUP BY 和ORDER BY中的表达式只涉及到一个表中的列(这样才能使用索引优化这个过程)

* 临时表(派生表)

  * 子查询
    * 先执行子查询并将结果放到一个临时表中,然后将这个临时表当作一个普通表对待
    * MySQL临时表是没有任何索引的,在编写复杂子查询时需要注意
  * UNION查询
    * 先将一个单表查询放到一个临时表中
    * 重新读出临时表数据来完成UNION查询

* 排序优化

  * 尽量让MySQL使用索引进行排序
  * 若数量太大超过“排序缓冲区”大小,MySQL只能采用文件排序,消耗资源

* 子查询优化

  * 用关联替换子查询

* 优化COUNT()查询

  * COUNT()作用
    * 统计某个列值的数量,即统计某列值不为NULL的个数
    * COUNT(*)统计行数

* 优化LIMIT分页

  * 使用索引覆盖扫描,而不是查询所有的列
  * 然后根据需要与万年青做一次关联操作返回所需要的列

* 使用UNION查询

  * 除非确实需要服务器消除重复的行,否则一定要使用UNION ALL
  * 如果没有ALL关键字,MySQL会给临时表加上DISTINCT选项,这会导致对整个临时表做唯一性检查,代价很大