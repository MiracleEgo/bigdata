# 民生银行笔试题

## 1、TCP/IP协议通过什么方式判别不同的进程。

进程，是一个应用程序实体，是程序运行所需资源分配的一个基本单位。首先程序不能在操作系统(OS)中独立运行，要想运行，首先得操作系统为之创建一个进程，**进程中包含了程度段（程序代码）、相关的数据段和一个进程控制块**。这个过程即把程序运行所需的资源都包装成一个进程，还为之创建一个管理和控制进程的模块.

TCP/IP协议是分了四层，最顶层是应用层，这里是应用程序，比如我们的QQ，接下来是**运输层**，这里是TCP和UDP两个协议，**负责将应用层要发送出去的信息进行分片**，相当于是生产线上的好多产品，先做一次简单的包装，但是这里有一个问题是我们系统的程序那么多，到底是哪个程序的数据要做一个标志，**TCP UDP规定使用一个16bit的端口号来表示应用程序**，表示数据来自是来自你的QQ呢还是MSN，还要加上目的端口号，表示你是想将数据发给QQ呢还是MSN，**即TCP/IP协议采用端口号的方式来判别不同的进程**。在下一层是网络层，这里是IP协议，还有ICMP,IGMP，当然IP是最重要的，这一层是继续将上面的包装过后的数据再封装一次，**加上源地址和目的地址**，好比快件，在这层要填上寄件人收件人，最后一层是**数据链路层**，差不多就是把刚刚**打包的快件放到车上**，发出去。

## 2、URL可以对应于几个IP地址

解析：URL即网页地址，俗称网址，术语叫**统一网络资源定位器**，比如：IP是计算机在网络中的门牌号，并且是唯一的，域名是这个门牌号码的文字形式表达，比如域名：就是域名，对应的IP为：61.135.185.29，你可以在cmd命令下ping这个域名或IP，效果都是一样的。也就是说**URL的域名是IP的文字化表现**，与IP对应，一个域名只能对应一个IP，多个域名可以被解析到同一个域名，成多对一的姿态。但URL不只是IP，比如这里的http表示的是http协议，然后跟着是域名以及需要访问的路径参数等。这里的答案是：**一个**。

## 3、查询数据库的时候，在什么情况下可能会导致死锁。

 锁是一个操作系统、多线程编程都涉及的重要概念，主要是**为了解决多任务对临界资源的争用问题**。比如打印机在打印任务时，打印机这是一个临界资源，只有一台，但可能有多台计算机同时给这台打印机下达打印任务，这时就要讲究临界资源的分配问题了，不然，多个打印任务的数据同时来不就乱了吗，一般来说，先来的任务线占据这台打印机执行任务，并上锁处理，别的任务一看到打印机上锁了就只能排队等待，打印机的某个任务完成后应该及时解锁，让后面正在排队等待的任务可以获得锁而执行任务。

我们来看一个银行业务系统，你可能在某银行开了两张借记卡A和B，存款分别为100和200，某天你想从账户A上取出钱50块存入账户B中，我们记这个事件为任务TaskOne，当然理所当然的最终结果是账户A只有50块，B账户上有250块，若是我们还有一个任务TaskTwo，即某个终端显示账户A和账户B的总金额，当然，理想情况是不变的总是300，但事实并非如此，若是这两个任务顺序执行，先执行TaskOne和TaskTwo，那么是没有任何问题的，但显示中，这两个任务是并行执行的，便可能有这种情况发生：当系统从A账户上扣掉50块时，A账户还剩50块，但你要转的50块还没到账户B上，账户B还是200，这时TaskTwo已经进行了一次操作，将账户A和账户B的总金额计算显示，于是显示金额为,250。造成这种结果的原因是TaskOne和TaskTwo是两个互不相干的任务，各自执行各自的，但访问的**资源却是共享**的，于是中间就出现了问题。现在假设我们有一把锁，当TaskOne任务从账户A中扣款时，我们对账户A加锁，不准其他任务访问，直到账户A上的现金已经到达账户B上，TaskOne再解锁，未解锁时TaskTwo是不能访问账户A上有多少现金的，只能排队等待，通过这种锁的机制，于是就可解决这种不同步的问题。

  然而，现在问题又有了，假设TaskOne任务执行时先后需要对资源ResourceOne和资源ResourceTwo进行访问，并且当前正在对资源ResourceOne访问，按前面的意思，访问时对它上了锁，在释放锁之前别的任务不能访问ResourceOne，只能排队等待。类似的，有任务TaskTwo需要先后对资源ResourceTwo和资源ResourceOne访问，当前正访问ResourceOne，也对其上了锁防止其他任务访问，于是问题来了，到了某一时刻，TaskOne还需要访问ResourceTwo，但被TaskTwo上锁，只好排队等，而恰好TaskTwo又需要访问ResourceOne，却被TaskOne上锁，也需等待，于是各自占据资源各自等待对方解锁，哪个一个任务都不能正常执行，这就是死锁。一个解决死锁的方式就是**事务回滚**，使得某个事物占据的资源解锁，从而是任务继续。这就是在一条比较窄的马路上开车，两车相遇，都需要这一段路的空间，我等着你开过，你等着我开过，最后谁也开不过，**只有某一方后退几步，各自都能顺利通过。**

## 4、软件工程里面：软件开发阶段包括哪些内容

一般是**需求分析 软件设计 编写代码 软件维护** 四个阶段吧，各有各的说法，但基本一致。《代码大全》列细的列出了十来条。

## 5、黑盒白盒测试的功能

第一次听说，这是关于软件测试方面的内容，可参考这篇文章

<http://blog.csdn.net/ningmeng2010/article/details/8114530>

## 6、哈弗曼编码，求编码后的平均长度

离散数学里的问题，网上这个题目没给完整，应该是蛮简单的。



## 7、排序算法的稳定性归类

所谓的稳定性是指当两个数想等排序后的先后位置是否和排序前保持一致，比如有两个数，A1在A2前面，排序时，我们会进行大小比较，知道A1=A2，经过排序后A1还是放在A2前面，这样的排序就是稳定的。反之不稳定。

不稳定排序：选择、快排，堆排，希尔排序；(快些选堆)


稳定的排序：归并、冒泡，插入，基数排序；![img](https://img-blog.csdn.net/20140508155647203?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjMzMzAwMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

## 9、TCP的三次握手

  TCP握手协议中计算机网络里很重要的一个知识点，具体可细看《TCP/IP详解，卷1：协议》一书。就像我们打电话，**第一阶段：你首先要拨号，发出通话链接信号，第二阶段：对方看到有来电显示了，摘下电话，说“喂”，第三阶段你听到对方的“喂”,也说一个“喂”,**于是通信就建立好了，可自由聊天说话了。TCP的三次握手很类似，它涉及客户端和服务端，服务端提供服务。

a.第一次握手是客户端发送请求（即我想和你进行通话），这个请求在**报文里含有一个同步序号SYN段，同时指明想要打开的服务器端口**，服务器上有好多端口。TCP是也是靠SYN标识对报文进行计数的，最后靠此序号来对数据报文重排序，同时该**报文的SYN位会置1，表示这是一个发起握手的信号**。

b.第二次握手服务端对客户端请求进行确认（即我知道你想和我通话了，我已经准备好了）。当服务端收到客户端发来数据包时，看到SYN位为1，知道有人申请服务，于是也发送一个类似的SYN段报文，并且还对刚刚收到的信息做出应答，**即在报文中确认序号上填充刚刚收到的那个同步序号+1，并将syn位和ack位都置1**，表示这是一个应答信号。

c.第三次握手客户端收对服务端的应答信号进行确认（服务端是说准备好了，但客户端准备好没好还没告诉服务端啊，所以这次握手是客户端告诉服务端，我知道你准备好了，现在我也准备好了，我们通话吧）。客户端收到服务端的回传的确认信息后，也还要再次确认，首先检查服务端发过来的确认序号是不是对的，以及位码ack是否为1，确认正确后，客户端也向服务端回复一个确认信息，即确认序列为刚刚服务端发来的同步序号+1，同时ack位置1。![img](https://img-blog.csdn.net/20140508165152156?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjMzMzAwMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

10、建数据库表，要求：有三个字段，c1，c2字符类型，c3，c4是整型，c5是日期类型，c2不能为空，c1 是主键

```sql
create table my_table
( c1 varchar(10),
  c2 varchar(10) not null,
  c3 int,
  c4 int,
  c5 datetime,
  primary key(c1));
```

# 民生银行面试题

## 1. JDK、JRE、JVM的区别与联系。

* JDK

JDK是JRE的超集，它包含了JRE的Java编译器，调试器和核心类。
JDK是用于开发的而JRE是用于运行Java程序的。
JDK和JRE都包含了JVM，从而使得我们可以运行Java程序。

* JVM

JVM是Java编程语言的核心并且具有平台独立性。

当我们运行一个程序时，JVM负责将字节码转换为特定机器代码。JVM也是平台特定的，并提供核心的Java方法，例如内存管理、垃圾回收和安全机制等。JVM 是可定制化的，我们可以通过Java 选项(java options)定制它，比如配置JVM 内存的上下界。JVM之所以被称为虚拟的是因为它提供了一个不依赖于底层操作系统和机器硬件的接口。这种独立于硬件和操作系统的特性正是Java程序可以一次编写多处执行的原因。

* JRE

如果你只是想要执行Java程序，你只需安装JRE即可，没有安装JDK的必要。

 

## 2. 在金融行业中，数据业务中为什么都用BIgDecimal，而不用Double和Float？

当使用double进行商业运算时，double计算会丢失精度。可以使用BigDecimal进行计算。

因为float和double都是浮点数, 都有取值范围, 都有精度范围. 浮点数与通常使用的小数不同, 使用中, 往往难以确定. 常见的问题是定义了一个浮点数, 经过一系列的计算, 它本来应该等于某个确定值, 但实际上并不是! 金额必须是完全精确的计算, 故不能使用double或者float, 而应该采用**java.math.BigDecimal.**

## 3. ArrayList和Vector，HashMap和HashTable的区别

ArrayList和HashMap是**异步**的，Vector和HashTable是**同步**的，所以Vector和HashTable是线程安全的，而ArrayList和HashMap并不是线程安全的。因为**同步需要花费机器时间**，所以Vector和HashTable的执行效率要低于ArrayList和HashMap。

```
Collection 
├List 
│├LinkedList 
│├ArrayList 
│└Vector 
│　└Stack 
└Set 
Map 
├Hashtable 
├HashMap 
└WeakHashMap 
```

* List接口  　　

List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于java的数组。 

 和下面要提到的Set不同，List允许有相同的元素。  　　

除了具有Collection接口必备的iterator()方法外，**List还提供一个listIterator()方法**，返回一个ListIterator接口，和标准的Iterator接口相比，ListIterator多了一些add()之类的方法，允许添加，删除，设定元素，还能向前或向后遍历。  　　

实现List接口的常用类有LinkedList，ArrayList，Vector和Stack。  

* ArrayList类  　　

ArrayList实现了**可变大小的数组**。它允许所有元素，包括null。ArrayList**没有同步**。  size，isEmpty，get，set方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。  　　

每个ArrayList实例都有一个**容量（**Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并没有定义。当需要插入大量元素时，**在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率**。  　　

和LinkedList一样，ArrayList也是**非同步**的（unsynchronized）。  

* Map接口  　　

请注意，**Map没有继承Collection接口，**Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个value。

Map接口提供3种集合的视图，Map的内容可以被当作一组key集合，一组value集合，或者一组key-value映射。  

* HashMap类 

　HashMap和Hashtable类似，不同之处在于**HashMap是非同步的，并且允许null，即null value和null key**。，但是将HashMap视为Collection时（values()方法可返回Collection），其迭代子操作时间开销和HashMap的容量成比例。因此，如果迭代操作的性能相当重要的话，不要将HashMap的初始化容量设得过高，或者load factor过低。

 





## 4. 在java并发编程中，同步和异步有哪些机制？

* Java是如何做到线程同步的呢？

1. 在需要同步的方法的 方法签名中加上 synchronized关键字
2. 使用synchronized关键字对需要进行同步的代码块进行同步
3. 使用java.util.concurrent.lock包中Lock对象（JDK1.8）

* synchronized的缺陷

 synchronized是java中的一个关键字，也就是说是Java语言内置的特性。那么为什么会出现Lock呢？

　　如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：

　　**1）获取锁的线程执行完了该代码块，然后线程释放对锁的占有；**

　　**2）线程执行发生异常，此时JVM会让线程自动释放锁。**

　　那么如果这个获取锁的线程由于要等待IO或者其他原因（比如**调用sleep方法**）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。

　　因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。

　　采用synchronized关键字来实现同步的话，就会导致一个问题：

　　如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。

　　**因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。**

总结一下，也就是说Lock提供了比synchronized更多的功能。但是要注意以下几点：

```
　　1）Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；
　　2）Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。
```

## 5. Java中的设计原则有哪些？谈谈你对最熟悉的设计原则的理解。

六大原则：

- **单一职责**
- **开闭原则**
- **里氏替换原则**
- **依赖倒置原则**
- **接口隔离原则**
- **迪米特法则**



- 单一职责原则（Single Responsibility Principle）

顾名思义，有点物以类聚，人以群分的感觉。一个类或一个方法应该只负责它应该负责的东西。比如有一个类：**loginController那么在此类中，就只写一些关于登录的相关代码，不要在这个类里又写和登录不相关的功能点，这样很便于代码的维护**







## 6. 日常开发中，谈谈你对异常代码的处理的经验。













根据表t_score(class,course,score)，写出查询每个班每科成绩排名前三名的SQL语句。
select t1.class,t1.course,t1.score from t_score t1 where (
select count(1) from t_score t2 where t2.class=t1.class and t2.course=t1.course and t2.score>=t1.score)<=3 order by t1.class , t1.score
【使用rank（）函数也可实现】

## 7. 写出DDL、DML、DCL的关键字（越完整越好）。

看图推出第五个图形，并写出理由。















