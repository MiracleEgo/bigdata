# redis 是什么？

## [五旬大爷教你一窥redis之谜](https://zhuanlan.zhihu.com/p/34762100)

”小伙子 你知道 redis的速度么？“

”**单机读可达10000次/S， 写可达 5000次/s“**

”恩 ，RDS巨擘mysql ，经过了这么多年优化 才1000次/S,500次/S，那么有么有想过redis为何这么吊么，“

”**redis 是操作内存，操作速度自然比mysql的磁盘操作要快太多了**“

”哎，世人肤浅，都只看到了redis的内存操作主导了优势，在我看来，这个原因也只是1/3(相比较RDS而言，最大优势是内存，**但是相对对于memcached等同类产品**)“

”？另外2分是？“

”哼哼，“

老爷子舔了舔手指，慢慢翻开。

”**数据结构！**大家都知道redis提供了5种数据类型的支持，却不知他们的其中奥妙，着实可惜，今日老夫就让你见识见识，

**redis最基础的是SDS(simple dynamic string),动态字符串**，与java c的字符串不同，他的定义是不单单是一个char 数组构成，每个sds都会比它真实占用的字符长度都长，**通过一个空闲标识符表示sds当前空闲字符有多少，如此设计，在一定长度范围的内的字符串都可以使用此sds，而且不会频繁的进行内存分配**，直到此sds不能容纳分配的字符串，如果遇到这种情况情况，才需要进行扩扩容，妙不可言；这是redis的最基础的，所有的redis k-v 中的字符串都是依托于sds，这是其一；

其二 **dict，字典，类似于java中的hashmap：数组，负载因子 hash算法**;

**不同于它的就是，每个dict拥有两个数组，一个简单的hash算法“**

“？两个数组？简单的hash算法”

**”java hashmap的hash算法是啥，对key进行hash，将hash值与当前的数组长度进行计算，获取当前key在数组中的索引值“**

”redis的很简单，就是key和一个定值运算，简单粗暴不是不伤手，保证了最快的执行速度，至于为啥两个数组，和hashmap一样，也要扩容，**初始的dic的数组长度不能太大，随着数据的增加，超过了负载因子，dic的数组必须进行扩容，hashmap怎么扩容？**“

”**新生一个更长的数组，遍历老数组向新数组的迁移“**

”原理差不多，**但是hashmap的扩张是一次性的，而redis的扩容是渐进式，不影响当前使用dic的正常使用，一点点划拉，直到迁移完成，这是其二**，

其三堪称一个杰作，你知道**mysql的索引的结构么**？“

“我知道B+树，”

”B+树，源于B树，也是自动平衡的树，随机查询性能举世无双，经过B+树的改进，压缩了整棵树的高度，在搜索性能又上一层楼，但是 二叉树也有自己的弊端，数据插入的平衡维持：左旋右旋，旋的我脑壳疼，拖了性能，而**我们即将说到的redis第三点，就是跳跃表，在随机搜索方面略低于B+树，但是对于数据插入，跳跃表使用了历史上最屌的算法：抛硬币，唯一能和这个算法媲美的只有掷骰子，推牌九，斗地主，扎金花等等“** 

### 跳跃表

“在跳跃表是由N层链表组成，最底层是最完整的的数据，每次数据插入，率先进入到这个链表（有序的），插入完成后，通过抛硬币的算法，判断是否将数据向上层抛，如果是1的话，就抛到上层，然后继续抛硬币，判断是否继续向上层抛，直到抛出了0结束整个操作，**每抛到一层的时候，如果当前层没有数据，就构造一个链表，将数据放进去，然后使用指针指向来源地址，**就这样依次类推，形成了跳跃表，每次查询，从最上层遍历查询，如果找到就返回结果，否则就在此层找到最接近查询的值，将查询操作移到另外一层，就是刚才说到来源地址，所在层，重复查询，第一次听到这跳跃表，简直比左旋右旋还头大，渐渐的领会到其要义：没事多推牌九，斗地主 扎金花

![img](https://pic4.zhimg.com/80/v2-114f4895c296861aca549d96fc4b563f_hd.jpg)

”哦，原理还有这个玩意，好神奇哦，这些数据结构就能解决redis的速度问题？“

”非也非也“

”这是**存储方面巧妙的地方之一，更主要是单线程+多路 I/O 复用模型**“

### 单线程+多路 I/O 复用模型

”单线程？单线程会更快。。。“

”如果说单线程更快的话 那简直是骗人的，**不过单线程的模式解决了数据存储的顽疾：数据并发安全，任何运行多线程同时访问数据库都会存在这个问题，所以才有了mysql的mvcc和锁， Memcached 的cas 乐观锁，来保证数据不会出现并发导致的数据问题，但是redis 使用单线程就不存在这个问题：1，单线程足够简单，无论在redis的实现还是作为调用方，都不需要为数据并发提心吊胆，不需要加锁。 2.不会出现不必要的线程调度，你知道多线程，频繁切换上下文，也会带来很多性能消耗“**

“额 。。。 **什么是切换上下文？**”

”你记得上次有个帅哥讲内存模型的时候（[两程序员玩“锁”，一人抢救无效身亡](http://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzUxODcyMDM3Mw%3D%3D%26mid%3D2247483669%26idx%3D1%26sn%3Dd6f1ef0444566a3e362485db8133f5ce%26scene%3D21%23wechat_redirect)），有提到工作内存么？**线程每次执行需要把数据从主内存读到工作内存，然而当线程被调度到阻塞的时候，这些工作内存的数据需要被快照到线程上下文中，其实就是一个记录各个线程状态的存储结构，等到线程被唤醒的时候，再从上下文中读取**，称之为上下文切换；减少上下文切换操作，也是使用单线程的奥妙；”

“。。。。” 

再说 **多路 I/O 复用模型**，这个也是java 的NIO体系使用的IO模型，也是linux诸多IO模型中的一种，说白了**就是当一个请求来访问redis后，redis去组织数据要返回给请求，这个时间段，redis的请求入口不是阻塞的，其他请求可以继续向redis发送请求，等到redis io流完成后，再向调用者返回数据，这样一来，单线程也不怕会影响速度了**

“哦 听起来很厉害，不过我再想**redis 真的是单线程就完全安全么**？”

“**当然不是。。。一个有趣的场景，如果请求1 2 3 同时发送修改redis的一个key值，这个是不可预期的，无法判断那个才是正确的，如果你认定第一个修改的为正确的，就需要借助redis其他的特性来完成，比如说watch，如果要保重多个操作原子性，就需要multi”**

“下面我必须要叮嘱你，redis持久化一定要慎重，AOF RDB,切不可瞎鸡巴用，redis集群的数据库同步，与mysql同步不同，别有洞天，最后老夫再传授你“如何避免缓存击穿”的奥秘”

### 缓存击穿

“？缓存击穿？是啥？”

“**缓存一般作为RDS的前置系统和服务器直连，减轻rds的负担，常理而言，如果服务器查询缓存而不得的话，需要从rds中获取然后更新到缓存中，但是如果在“*从rds中获取然后更新到缓存中*”，这个阶段，缓存尚未更新成功，大量请求进来的话，rds势必压力暴增，甚至雪崩，或者歹人恶意攻击，一直查询rds和缓存中未存在key，也会导致缓存机制失效，rds压力暴增，称之为缓存击穿，**

”前辈 那该咋儿办？“

### 缓存击穿怎么办？

”**缓存永不失效，定时同步rds redis，不允许应用直接请求查询rds，所有的查询以缓存中为准**“

”那且不是数据不能实时展示了么，“

”对的，不过你就认为服务器临时上了一个厕所，耽误个几分钟，这样会好受些“

”如果定时器挂了怎么办“

”服务器挂了怎么办？其实道理一样的，如何避免服务器宕机，就如何避免定时器挂机“

”哦“ 



![img](https://pic1.zhimg.com/80/v2-80e2dad3fb42da98fdb10ad97a00b5e0_hd.jpg)



# [【最全Java面试题】Redis面试题目49道附答案](https://zhuanlan.zhihu.com/p/58333436)

## **Redis支持哪几种数据类型？**

支持多种类型的数据结构

1.string：最基本的数据类型，二进制安全的字符串，最大512M。

2.list：按照添加顺序保持顺序的字符串列表。

3.set：无序的字符串集合，不存在重复的元素。

4.sorted set：已排序的字符串集合。

5.hash：key-value对的一种集合。

![img](https://pic1.zhimg.com/80/v2-9f60b2278b9cedc0aaae7c22d2a02b34_hd.jpg)

##  **Redis主要有哪些功能？**

**1.哨兵（Sentinel）和复制（Replication）**

Redis服务器毫无征兆的罢工是个麻烦事，如何保证备份的机器是原始服务器的完整备份呢？这时候就需要哨兵和复制。

哨兵Sentinel可以管理多个Redis服务器，它提供了监控，提醒以及自动的故障转移的功能，Replication则是负责让一个Redis服务器可以配备多个备份的服务器。

Redis也是利用这两个功能来保证Redis的高可用的。

**2.事务**

很多情况下我们需要一次执行不止一个命令，而且需要其同时成功或者失败。redis对事务的支持也是源自于这部分需求，即支持一次性按顺序执行多个命令的能力，并保证其原子性。

**3.LUA脚本**

在事务的基础上，如果我们需要在服务端一次性的执行更复杂的操作（包含一些逻辑判断），则lua就可以排上用场了。

**4.持久化**

redis的持久化指的是redis会把内存的中的数据写入到硬盘中，在redis重新启动的时候加载这些数据，从而最大限度的降低缓存丢失带来的影响。

**5.集群（Cluster）**

单台服务器资源的总是有上限的，CPU资源和IO资源我们可以通过主从复制，进行读写分离，把一部分CPU和IO的压力转移到从服务器上，这也有点类似mysql数据库的主从同步。

在Redis官方的分布式方案出来之前，有twemproxy和codis两种方案，这两个方案总体上来说都是依赖proxy来进行分布式的，**下面的内容有具体集群方案详解。**

## **Redis是单进程单线程的？**

Redis是单进程单线程的，Redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。

## **Redis为什么是单线程的？**

多线程处理会涉及到锁，而且多线程处理会涉及到线程切换而消耗CPU。因为CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存或者网络带宽。单线程无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来解决。

##  **使用Redis的优势？**

1. 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)

2. 支持丰富数据类型，支持string，list，set，sorted set，hash
3. 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行

4. 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除

## **Redis单点吞吐量**

单点TPS达到8万/秒，QPS达到10万/秒，补充下TPS和QPS的概念

**1.QPS:** **应用系统每秒钟最大能接受的用户访问量**

每秒钟处理完请求的次数，注意这里是处理完，具体是指发出请求到服务器处理完成功返回结果。可以理解在server中有个counter，每处理一个请求加1，1秒后counter=QPS。

**2.TPS：** **每秒钟最大能处理的请求数**

每秒钟处理完的事务次数，一个应用系统1s能完成多少事务处理，一个事务在分布式处理中，可能会对应多个请求，对于衡量单个接口服务的处理能力，用QPS比较合理。

## **Redis相比memcached有哪些优势？**

1. memcached所有的值均是简单的字符串，Redis作为其替代者，支持更为丰富的数据类型
2. Redis的速度比memcached快很多
3. Redis可以持久化其数据
4. Redis支持数据的备份，即master-slave模式的数据备份。

##  **Redis有哪几种数据淘汰策略？**

在Redis中，允许用户设置最大使用内存大小server.maxmemory，当Redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。

1.volatile-lru:从已设置过期的数据集中挑选最近最少使用的淘汰

2.volatile-ttr:从已设置过期的数据集中挑选将要过期的数据淘汰

3.volatile-random:从已设置过期的数据集中任意挑选数据淘汰

4.allkeys-lru:从数据集中挑选最近最少使用的数据淘汰

5.allkeys-random:从数据集中任意挑选数据淘汰

6.noenviction:禁止淘汰数据

redis淘汰数据时还会同步到aof

## **Redis集群方案应该怎么做？都有哪些方案？**

1.twemproxy

2.codis，目前用的最多的集群方案，基本和twemproxy一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新hash节点。

3.Redis cluster3.0自带的集，特点在于他的分布式算法不是一致性hash，而是hash槽的概念，以及自身支持节点设置从节点。

## **Redis读写分离模型**

通过增加Slave DB的数量，读的性能可以线性增长。为了避免Master DB的单点故障，集群一般都会采用两台Master DB做双机热备，所以整个集群的读和写的可用性都非常高。

读写分离架构的缺陷在于，不管是Master还是Slave，每个节点都必须保存完整的数据，如果在数据量很大的情况下，集群的扩展能力还是受限于单个节点的存储能力，而且对于Write-intensive类型的应用，读写分离架构并不适合。

## **Redis数据分片模型**

为了解决读写分离模型的缺陷，可以将数据分片模型应用进来。

可以将每个节点看成都是独立的master，然后通过业务实现数据分片。

结合上面两种模型，可以将每个master设计成由一个master和多个slave组成的模型。

##  **Redis提供了哪几种持久化方式？**

**RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储**

**AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以Redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大.**

如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.

你也可以同时开启两种持久化方式, 在这种情况下, 当Redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.

最重要的事情是了解RDB和AOF持久化方式的不同,让我们以RDB持久化方式开始。 

**如何选择合适的持久化方式？**

1. Redis主要提供了两种持久化机制：**RDB和AOF**

**2.  RDB**

默认开启，会按照配置的指定时间将内存中的数据快照到磁盘中，创建一个dump.rdb文件，Redis启动时再恢复到内存中。

Redis会单独创建fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。

需要注意的是，每次快照持久化都会将主进程的数据库数据复制一遍，导致内存开销加倍，若此时内存不足，则会阻塞服务器运行，直到复制结束释放内存；都会将内存数据完整写入磁盘一次，所以如果数据量大的话，而且写操作频繁，必然会引起大量的磁盘I/O操作，严重影响性能，并且最后一次持久化后的数据可能会丢失；

**3.AOF**

以日志的形式记录每个写操作（读操作不记录），只需追加文件但不可以改写文件，Redis启动时会根据日志从头到尾全部执行一遍以完成数据的恢复工作。包括flushDB也会执行。

主要有两种方式触发：有写操作就写、每秒定时写（也会丢数据）。

因为AOF采用追加的方式，所以文件会越来越大，针对这个问题，新增了重写机制，就是当日志文件大到一定程度的时候，会fork出一条新进程来遍历进程内存中的数据，每条记录对应一条set语句，写到临时文件中，然后再替换到旧的日志文件（类似rdb的操作方式）。默认触发是当aof文件大小是上次重写后大小的一倍且文件大于64M时触发。

当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。一般情况下，只要使用默认开启的RDB即可，因为相对于AOF，RDB便于进行数据库备份，并且恢复数据集的速度也要快很多。

开启持久化缓存机制，对性能会有一定的影响，特别是当设置的内存满了的时候，更是下降到几百reqs/s。所以如果只是用来做缓存的话，可以关掉持久化。































## redis都有哪些使用场景？

[聊聊 Redis 使用场景](https://zhuanlan.zhihu.com/p/56154153)

随着数据量的增长，MySQL 已经满足不了大型互联网类应用的需求。因此，Redis 基于内存存储数据，可以极大的提高查询性能，对产品在架构上很好的补充。在某些场景下，可以充分的利用 Redis 的特性，大大提高效率。 

* 缓存 

**对于热点数据，缓存以后可能读取数十万次**，因此，对于热点数据，缓存的价值非常大。例如，分类栏目更新频率不高，但是绝大多数的页面都需要访问这个数据，因此读取频率相当高，可以考虑基于 Redis 实现缓存。 

* 会话缓存

 此外，还可以考虑使用 Redis 进行会话缓存。例如，将 web session 存放在 Redis 中。 

* 时效性 

例如验证码只有60秒有效期，超过时间无法使用，或者基于 Oauth2 的 Token 只能在 5 分钟内使用一次，超过时间也无法使用。 

* 访问频率 

出于减轻服务器的压力或防止恶意的洪水攻击的考虑，需要控制访问频率，例如限制 IP 在一段时间的最大访问量。 

* 计数器 

数据统计的需求非常普遍，通过原子递增保持计数。例如，应用数、资源数、点赞数、收藏数、分享数等。 

* 社交列表 

社交属性相关的列表信息，例如，用户点赞列表、用户分享列表、用户收藏列表、用户关注列表、用户粉丝列表等，使用 Hash 类型数据结构是个不错的选择。

*  记录用户判定信息 

记录用户判定信息的需求也非常普遍，可以知道一个用户是否进行了某个操作。例如，用户是否点赞、用户是否收藏、用户是否分享等。 

* 交集、并集和差集

 在某些场景中，例如社交场景，通过交集、并集和差集运算，可以非常方便地实现共同好友，共同关注，共同偏好等社交关系。 

* 热门列表与排行榜 

按照得分进行排序，例如，展示最热、点击率最高、活跃度最高等条件的排名列表。 

* 最新动态

 按照时间顺序排列的最新动态，也是一个很好的应用，可以使用 Sorted Set 类型的分数权重存储 Unix 时间戳进行排序。 

* 消息队列 

Redis 能作为一个很好的消息队列来使用，依赖 List 类型利用 LPUSH 命令将数据添加到链表头部，通过 BRPOP 命令将元素从链表尾部取出。同时，市面上成熟的消息队列产品有很多，例如 RabbitMQ。因此，更加建议使用 RabbitMQ 作为消息中间件。

## **Redis常见性能问题和解决方案？**

(1) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件

(2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次

(3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内

(4) 尽量避免在压力很大的主库上增加从库

(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1 <- Slave2 <- Slave3...

这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。

 

## **Redis支持的Java客户端都有哪些？官方推荐用哪个？**

Redisson、Jedis、lettuce等等，官方推荐使用Redisson。

## **Redis哈希槽的概念？**

Redis集群没有使用一致性hash,而是引入了哈希槽的概念，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384的值，决定将一个key放到哪个桶中。

## **Redis集群最大节点个数是多少？**

Redis集群预分好16384个桶(哈希槽)

## **Redis集群的主从复制模型是怎样的？**

为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品.

## **Redis集群会有写操作丢失吗？为什么？**

Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。

## **Redis集群之间是如何复制的？**

异步复制

## **Redis如何做内存优化？**

尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面.

##  **Redis回收进程如何工作的？**

一个客户端运行了新的命令，添加了新的数据。

Redi检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。

## **Redis回收使用的是什么算法？**

LRU算法

## **Redis有哪些适合的场景？**

1）Session共享(单点登录)

2）页面缓存

3）队列

4）排行榜/计数器

5）发布/订阅

 

 

 

 

 

 

 

 

  

 

 

 

   

 

 

# jedis 和 redisson 有哪些区别？

# 怎么保证缓存和数据库数据的一致性？

# redis 怎么实现分布式锁？

# redis 分布式锁有什么缺陷？





