# 接口（带有默认方法）与类的区别

* 相同点
  * 都可以有方法实现（Java8 之前接口不能有方法实现）
  * 子类不需要实现全部的方法（Java8 之前接口的子类需要实现全部的方法）
* 不同点
  * 抽象类不可以多重继承，接口可以
  * 抽象类表示的是"is-a"关系，接口表示的是"like-a"关系
  * 接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能改变其值
  * 抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以重新赋值

# 为什么interface里的变量是 static final 的？

* static

必须。因为接口是可以多继承的。如果一个类实现了两个接口，且两个接口都具有相同名字的变量，此时这个变量可以被实现类使用，那么如果不是static的，这个变量来自哪一个接口就会产生歧义，所以实现类使用接口中的变量必须通过接口名指定，也就只能定为static的。

* final

我认为因为必须是static的，那么所有子类共享，而接口是一种抽象， 所以一个子类修改了值会影响到其他所有子类，因此就不应该允许子类修改这个值，所以定义为final。

# 如何选择

现在我们知道了，抽象类定义了“是什么”，可以有非抽象的属性和方法；接口是更纯的抽象类，在 Java 中可以实现多个接口，因此接口表示“具有什么能力”。

在进行选择时，可以参考以下几点：

- 若使用接口，我们可以同时获得抽象类以及接口的好处
- 所以假如想创建的基类没有任何方法定义或者成员变量，那么无论如何都愿意使用接口，而不要选择抽象类
- 如果事先知道某种东西会成为基础类，那么第一个选择就是把它变成一个接口
- **只有在必须使用方法定义或者成员变量的时候，才应考虑采用抽象类**

此外使用接口最重要的一个原因：**实现接口可以使一个类向上转型至多个基础类。**

比如 `Serializable` 和 `Cloneable` 这样常见的接口，一个类实现后就表示有这些能力，它可以被当做 `Serializable` 和 `Cloneable` 进行处理。

> 推荐接口和抽象类同时使用，这样既保证了数据的安全性又可以实现多继承。 













