# 策略模式

定义一系列算法，将每一个算法封装起来，并让他们可以相互替换。策略模式让算法可以铁立于使用它的客户而变化

票价打折案例



# 迭代器模式

提供一种方法顺序访问一个聚合对象中的各个元素，成果又不用暴露该对象的内部表示

JDK中的Colloction



# 装饰器模式

动态地给一个对象增加一些客外的职责。就扩展功能而言，装饰器模式提供了一种比使用子类更加灵活的替代方案

Java I/O 输入流，输出流的设计，javax.swing包中一些图形界面构件功能的增强等地方都用了装饰模式。

* （扩展一个对象的功能，装饰模式比继承更加灵活，不会导致类的个数急剧增加）
* 可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合可以创造出很多种不同行为和组合，得到功以能更强大的对象
* 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合开闭原则。

# 观察者模式

* 定义对象之间的一种一对多的信赖关系，便得每当一个对象状态发生改变时其相关依赖对象皆得到通知并被动更新。
* 别名：  发布订阅模式，源-监听器模式，从属者模式
* MVC应用



# 简单工厂模式

# 工厂方法模式

# 代理模式

* 代购案例
* 给某个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问
* 在代理模式中引入了一个新的代理对象，代理对象地客户端和目标对象之间起到中介的作用，它去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。
* 远程代理
* 虚拟代理
* 动态代理 （事务管理  AOP）

# 模板方法模式

* 请客吃饭案例

模板方法模式是基于继承的代码复用技术，它体现了面向对象的诸多重要思想，是一种使用较为频繁的设计模式。模板方法模式广泛应用于框架设计（例如：Spring，JUnit等）中，以确保通过父类来控制处理流程的逻辑顺序（例如框架的寝化，测试流程和设置等）





# 享元模式

当系统中存在大量相同或者相似的对象时，享元模式是一种值得考虑的解决方案，它通过共享技术实现相同或相似的细粒度对象的利用，从而节约了内存空间，提高了系统性能。

* 围棋案例
* String类使用了享元模式

# 单例模式

对于一个软件系统中的某些类而言，只有一个实例很重要，例如一个系统只能有一个窗口管理器或文件系统，一个系统只能有一个计时工具或ID（序号）生成器等。

如果不使用机制对窗口对象进行唯一化，势必会弹出多个窗口。如果这些窗口显示的内容完全一致，则是重复对象，浪费内存资源。如果这些窗口显示的不一致，则意味着在某一瞬间系统有多个状态，与实际不符，也会给用户带来误解，不知道哪一个才是真实的状态。

* 饿汉式单例

* 懒汉式单例

  双重检查锁定实现

* 使用静态内部类来创建单例模式
  

