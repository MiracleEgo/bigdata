# Java特性

## 封装

* 隐藏对象的属性和实现细节，仅对外公开接口,控制在程序中属性的读和修改的访问级别。

## 继承

* 实现代码的复用。

##  多态

> 同一种事物表现出的多种形态。

* 多态的实现方式
  * 基于继承实现的多态

  * 基于接口实现的多态

  * 多态的存在有三个前提
    * 要有继承关系 
    	 子类要重写((override))父类的方法	
    * 父类引用指向子类对象,
* 多态性主要表现在如下两个方面:

  * 方法重载
    * 通常指在同一个类中,相同的方法名对应着不同的方法实现,但是方法的参数不同.
  * 成员覆盖
    * 通常指在不同类(父类和子类)中,允许有相同的变量名,但是数据类型不同;也允许有相同的方法名，但是对应的方法实现不同.
* 多态的好处

  * 程序的可扩展性及可维护性增强。
* 成员变量

  * 编译和运行都参考左边。
* 成员函数（非静态）

  * 编译看左边，运行看右边
* 静态函数
  * 编译和运行都看左边。

# Java对象在内存中布局

* 对象头
  * 实现Synchronized锁对象基础
  * 2个机器码(32位是8字节)存储对象头,如果是数组,则为3机器(12字节)码,多出来一个记录数组长度
* # 实例数据

  * 类属性信息,包括父类属性信息
  * 若数组的实例部分要包括数组的长度
  * 4字节对齐
* 对齐填充
  * 虚拟机要求对象起始地址为8字节整数倍
  * 填充数据不是必须存在

# List,Set,Collection,Collections

1.List和Set都是接口，他们都继承于接口Collection,List是一个有序的可重复的集合，而Set的无序的不可重复的集合。Collection是集合的顶层接口，Collections是一个封装了众多关于集合操作的静态方法的工具类,因为构造方法是私有的，所以不能实例化。

2.List接口实现类有ArrayList,LinkedList,Vector。ArrayList和Vector是基于数组实现的,所以查询的时候速度快，而在进行增加和删除的时候速度较慢LinkedList是基于链式存储结构，所以在进行查询的时候速度较慢但在进行增加和删除的时候速度较快。又因为Vector是线程安全的，所以他和ArrayList相比而言，查询效率要低。

# 类的实例化顺序

* 加载类

  1. 为父类静态属性分配内存并赋值 / 执行父类静态代码段 （按代码顺序）

  2. 为子类静态属性分配内存并赋值 / 执行子类静态代码段 （按代码顺序）
* 创建对象

  1. 为父类实例属性分配内存并赋值 / 执行父类非静态代码段 （按代码顺序）
  2. 执行父类构造器
  3. 为子类实例属性分配内存并赋值 / 执行子类非静态代码段 （按代码顺序）
  4. 执行子类构造器  


# Java重写(override)与重载(overload)

* 重写

  * 重写是子类对父类的允许访问的方法的实现过程进行重新编写,
  * 返回值和形参都不能改变。
  * **即外壳不变，核心重写！**

* 重载

  * 在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。
  * 每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。
  * 最常用的地方就是构造器的重载。

* 重载规则

  - 被重载的方法必须改变参数列表(参数个数或类型不一样)；
  - 被重载的方法可以改变返回类型；
  - 被重载的方法可以改变访问修饰符；
  - 被重载的方法可以声明新的或更广的检查异常；
  - 方法能够在同一个类中或者在一个子类中被重载。
  - 无法以返回值类型作为重载函数的区分标准。

* 重写与重载的区别

  | 区别点   | 重载方法 | 重写方法                                       |
  | -------- | -------- | ---------------------------------------------- |
  | 参数列表 | 必须修改 | 一定不能修改                                   |
  | 返回类型 | 可以修改 | 一定不能修改                                   |
  | 异常     | 可以修改 | 可以减少或删除，一定不能抛出新的或者更广的异常 |
  | 访问     | 可以修改 | 一定不能做更严格的限制（可以降低限制）         |

  ![img](https://www.runoob.com/wp-content/uploads/2013/12/20171102-1.jpg)



# 运算符优先级

单目运算符：+，-，++，--

算数运算符：+，-，*，/，%

移位运算符：<<,>>

关系运算符：>,<,>=,<=,==,!=

位运算符：&，|，~，^,

逻辑运算符：&&，||

三目运算符：表达式1？表达式2：表达式3;

赋值运算符：=等

 

# switch

switch 语句中的变量类型可以是：

 byte、short、int 或者 char。

从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。



# equals与hashCode()

- 若两对象相同.equals返回true,则hashCode值必相同
- 若两对象hashCode相同,equals可能为false
- hashCode
  - 对象比较时先进行hashCode比较.若不同,则没有后序比较必要.减少了equals比较次数,效率提高
  - 集合中的例子
    - set集合不重复且无序,在插入时会判断是否重复,若用equals则全都要比较一遍,使用hash表大大减少比较的次数
- 为何必须重写hashCode
  - equals根据对象的特征重写的
  - 保证同一对象在equals相同时hashCode必相同

# ==与equals的区别

* equals由开发者自己写逻辑,默认为==
* String重写了equals,比较字符是否相同
* ==判断两个判断是否或实例是不是指向同一个内存空间
* equals判断两个变量或实例所指向的内存空间的值是否相同
* 基本数据类型用==比较的是值

# sleep和wait的区别

![](https://pic2.zhimg.com/80/bb4f380c79779c9dc1aea6f0a6c10b6d_hd.jpg)

* sleep让线程阻塞,特定时间后转为非阻塞,重新获得CPU
* wait调用时先获得该Object的锁,调用wait后将锁释放并阻塞.当调用notify/notifyAll后,可能获得CPU重新获得锁

# Clone()

* 声明为`protected Object clone() CloneNotSupportedException`
* 无论浅拷贝还是深拷贝,都需要实现clone()方法以及`Cloneable`接口来完成操作
* 浅拷贝
  * 对基本数据类型进行值传递,对引用数据类型进行引用传递
* 深拷贝
  * 对基本数据类型进行值传递,对引用数据类型,创建一个新的对象,并复制其内容
  * 实现方案
    * 序列化`serialization`这个对象,再反序列化回来,就可以得到新的对象
    * 利用`clone()`,对其内的引用类型的变量再进行一次`clone()`