# IO类型

* 概念
  * 用户空间与内核空间
    * 操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限
    * Linux操作系统将最高的1G字节供内核使用，将较低的3G字节，供各个进程使用
  * 进程切换
    * 内核必须有能力挂起在CPU上运行的进程，并恢复以前挂起的某个进程的执行，任何进程都是在操作系统内核的支持下运行的
    * 过程
      * 保存处理机上下文，包括程序计数器和其他寄存器
      * 更新PCB信息
      * 把进程的PCB移入相应的队列，如就绪，在某事件阻塞等队列
      * 选择另一个进程执行，并更新PCB
      * 更新内存管理的数据结构
      * 恢复处理机上下文
  * 进程阻塞
    * 是进程自身的一种主动行为，只有处于运行态的进程，才能将其转为阻塞状态。
    * 不占用CPU资源
  * 文件描述符fd
    * 表述指向文件的引用的抽象化概念
    * 一个非负整数，实际是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表
  * 缓存IO
    * 大多文件系统默认IO操作都是缓存IO
    * 操作系统会将IO的数据缓存在文件系统的页缓存中，数据会先被拷贝到内核缓冲区，再拷贝到应用程序的地址空间
    * 缺点
      * 传输过程中需要大应用程序地址为僮和内核进行多次数据拷贝操作，操作带来的CPU及内存开销非常大
  * 网络IO
    * 同步IO
    * BIO阻塞IO
    * 非阻塞IO
    * IO多路复用
    * 信号驱动IO
    * 异步IO

## 同步阻塞BIO

* 能够及时返回数据，无延迟
* 用户需付出性能的代价
* 常用类
  * InputStream
  * OutputStream
  * Reader
  * Writer

## 同步非阻塞NIO

* 轮询检查内核数据，直到数据准备好，再拷贝数据到进程(用户空间)，进行处理

* 优点
  * 能够在等待任务完成的时间里干其他活

* 缺点
  * 任务完成的响应延迟增大，因每过一段时间才轮询一次read操作，而任务可能在两次轮询之间的任意时间完成，整个数据吞吐量降低

### NIO与IO区别

  - IO是面向流，NIO是面向缓冲区
  - IO流阻塞，NIO流不阻塞
  - NIO有选择器，而IO没有

### NIO原理

* 核心组件
  * 通道`Channels`
    * Scatter: 从一个Channel读取的信息分散到N个缓冲区中(Buffer).
    * Gather: 将N个Buffer里面内容按照顺序发送到一个Channel.
    * 类型
      * `FileChannel`从文件读写数据 
      * `DataGramChannel`通过UDP读写网络数据
      * `SocketChannel`通过TCP
      * `ServerSocketChannel`可以监听新来的TCP连接,为每个连接建立一 个SocketChannel
  * 缓冲区`Buffers`
    * 缓冲区实质是一个数组(内存区)
    * 从Buffer把数据写入到Channels；从Channel中读取数据到buffers
    * Buffer本质上就是一块内存区；
    * 类型
      * `ByteBuffer`
      * `CharBuffer`
      * `ShortBuffer`
      * `IntBuffer`
      * `LongBuffer`
      * `FloatBuffer`
      * `DoubleBuffer`
    * 状态变量
      * `capacity`最大容量
      * `position`当前已读写字节数
      * `limit`还可以己度人读写字节数
  * 选择器`Selectors`
    * `Selector`选择器 / 多路复用器 
    * 一个线程用selector监听多个channel事件,实现IO多路复用
    * 避免了线程上下文切换带来的开销

## IO多路复用

* `select , poll, epoll`   (系统级别)
  * 单个process就可以同时处理多个网络连接的IO
  * 不断轮询所负责的所有socket，当某个socket有数据到达，就通知用户进程
* 实际中对于每一个socket，一般都设置成NIO，但是整个用户的process其实是一直被block的，不过process是被block这个函数block，而不是被socket IO给Block
* IO多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的IO系统调用之上
* 通过把多个IO的阻塞复用到同一个select有阻塞上，从而使系统在单线程情况下，可以同时处理多个客户端请求

## 异步非阻塞AIO

* BIO在IO操作时开始阻塞应用程序，这意味着不可能同时重叠进行处理和IO操作
* NIO允许处理和IO操作重叠进行。但需要应用程序根据重现的规则来检查IO操作的状态
* AIO允许处理和IO操作重叠进行，包括IO操作完成的通知

# blocking与non-blocking区别

* blocling会一直block对应的进程直到操作完成
* non-blocking在kernel(内核)还准备数据的情况下立刻返回

# 同步IO与异步IO的区别

* 同步IO在 IO时会将process阻塞
  * BIO
  * NIO
    * 如果kernel数据没有准备好，这时不会block
    * 当kernel数据准备好的时候，将数据从内核拷贝到用户内存，为时进程被block
  * IO multiplexing
* 异步IO
  * 发起IO操作之后，直接返回，直到kernel发出信号，告诉进程IO完成



# IO多路复用

* 适用场合

  * 当处理多个描述符时
  * 一个客户处理多个套接口
  * 一个TCP服务器即要处理TCP，又要处理UDP
  
## select

  > select 函数监视文件描述符，调用后select函数会阻塞，直到有描述符就绪，或者超时，函数返回
  >
  > 当select函数返回后，可通过遍历fdset，找到就绪的描述符

  * select本质是通过设置或检查存放fd标志位的数据结构来进行下一步处理

  * 优势

    * 跨平台

  * 缺点

    * 单进程能够监视的文件描述符的数量存在最大限制，Linux一般为1024，可通过宏定义甚至重新编译内核的方式提升这一限制，但也会造成效率降低
    * 对socket扫描时是线性扫描，即采用轮询的方法，效率较低
      * 不管socket是否活跃，都遍历一遍，会浪费很好CPU时间
    * 需要维护一个存放大量fd的数据结构，这样使用户空间与内核空间在传递结构时复制开销大

## poll

  > poll本质与select无区别,查询每个fd对应的设备状态,如果设备就绪则在设备等待队列中加入一项并继续遍历,如果遍历完所有fd后没有发现就绪设备,挂起当前进程,直到设备就緒或主动超时,被唤醒后它又要再次遍历fd,过程经历了多次无谓的遍历

  * 基于链表存储,没有最大连接数限制
  * 缺点
    * 大量fd数组被整体复制于用户态与内核之间,而不管是否有意义
    * 如果报告了fd后,没有被处理,下次poll会再次报告该fd(水平触发)
  * select与poll都需要在返回后,通过遍历文件描述符来获取已经就绪的socket

## epoll

  > 使用一个fd管理多个fd,将用户关系的fd的事件放到内核的一个事件表中,用户空间和内核空间的copy只需一次

  * 原理
    * 支持水平触发和边缘触发(只告诉进程哪些fd刚刚变为就绪态,并且只通知一次)
    * epoll使用事件的就绪通知方式,一旦fd就绪,内核就会采用类似callback的回调机制来激活该fd
  * 优点
    * 没有最大并发连接的限制
    * 效率提升,不是轮询的方式,不会随着fd数目的增加效率下降,只有活跃的fd都会调用callback
    * 内存拷贝开销小
  * 文件描述符操作模式
    * LT(level trigger)
      * 检测到描述符事件发生并将此事件通知应用程序,应用程序可不处理,下次调用epoll_wait时,会再次响应应用程序并通知该事件
    * ET(edge trigger)
      * 检测到描述符事件发生并通知应用程序,应用程序立即处理,若不处理,下次不会通知

### [水平触发和边缘触发](https://blog.csdn.net/lihao21/article/details/67631516)

* 水平触发
* 边缘触发

## Select和epoll的区别

* 每次调用select,都要把fd(文件描述符)从用户态拷贝到内核态,在fd很多时开销大
* 每次调用select都要在内核遍历传递进来的所有fd,在fd很多时开销时大
* select支持的文件供述符数量太小,默认为1024
* epoll为每个fd指定一个回调函数,当设备准备就绪时,唤醒等待队列上的等待者时,就会调用这个回调函数
* epoll所支持的fd上限是最大可以打开文件数目

# 字节流转与字符流

## 将字节流转为字符流

* `InputStreamReader `类是从字节流到字符流的桥梁
  * 它读入字节，根据指定的编码方式，转为字符流    
* `OutputStreamWriter`类是从字符流转换成字节流

## 字符流与字符流区别

* 字节流操作时与文件本身直接操作，不会用到缓冲区。字符流会使用
* 字符流在操作文件时需使用`close()`方法，否则不输出内容
  * 说明其使用的是缓冲区，可使用flush()方法强制刷新缓冲区，此时才能在不close下输出
* Reader类的`read()`返回类型为int（0-65535）,若到流末尾，则返回-1
* inputStream类的`read()`也返回int，（0-255），若到末尾，则为-1
  * 汉字不能用0-255来表示。故只能用字符流
* 处理方式
  * 字节流处理字节和字节数组或二进制对象
  * 字符流处理字符，字符数组或字符串