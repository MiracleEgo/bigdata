# IO类型

* 概念
  * 用户空间与内核空间
    * 操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限
    * Linux操作系统将最高的1G字节供内核使用，将较低的3G字节，供各个进程使用
  * 进程切换
    * 内核必须有能力挂起在CPU上运行的进程，并恢复以前挂起的某个进程的执行，任何进程都是在操作系统内核的支持下运行的
    * 过程
      * 保存处理机上下文，包括程序计数器和其他寄存器
      * 更新PCB信息
      * 把进程的PCB移入相应的队列，如就绪，在某事件阻塞等队列
      * 选择另一个进程执行，并更新PCB
      * 更新内存管理的数据结构
      * 恢复处理机上下文
  * 进程阻塞
    * 是进程自身的一种主动行为，只有处于运行态的进程，才能将其转为阻塞状态。
    * 不占用CPU资源
  * 文件描述符fd
    * 表述指向文件的引用的抽象化概念
    * 一个非负整数，实际是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表
  * 缓存IO
    * 大多文件系统默认IO操作都是缓存IO
    * 操作系统会将IO的数据缓存在文件系统的页缓存中，数据会先被拷贝到内核缓冲区，再拷贝到应用程序的地址空间
    * 缺点
      * 传输过程中需要大应用程序地址为僮和内核进行多次数据拷贝操作，操作带来的CPU及内存开销非常大
  * 网络IO
    * 同步IO
    * BIO阻塞IO
    * 非阻塞IO
    * IO多路复用
    * 信号驱动IO
    * 异步IO

## 同步阻塞BIO

* 能够及时返回数据，无延迟
* 用户需付出性能的代价

## 同步非阻塞NIO

* 轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行处理
* 优点
  * 能够在等待任务完成的时间里干其他活
* 缺点
  * 任务完成的响应延迟增大，因每过一段时间才轮询一次read操作，而任务可能在两次轮询之间的任意时间完成，整个数据吞吐量降低
* 与IO区别
  - IO是面向流的，NIO是面向缓冲区的；
  - IO流是阻塞的，NIO流是不阻塞的;
  - NIO有选择器，而IO没有。
* 核心组件
  * Channels
    * Scatter: 从一个Channel读取的信息分散到N个缓冲区中(Buufer).
    * Gather: 将N个Buffer里面内容按照顺序发送到一个Channel.
  * Buffers
    * Java NIO Buffers用于和NIO Channel交互。 我们从Channel中读取数据到buffers里，从Buffer把数据写入到Channels；
    * Buffer本质上就是一块内存区；
    * 一个Buffer有三个属性是必须掌握的，分别是：capacity容量、position位置、limit限制。
    * Buffer的常见方法
      - Buffer clear()
      - Buffer flip()
      - Buffer rewind()
      - Buffer position(int newPosition)
  * Selectors
    * Selector 一般称 为选择器 ，当然你也可以翻译为 多路复用器 。它是Java NIO核心组件中的一个，用于检查一个或多个NIO Channel（通道）的状态是否处于可读、可写。如此可以实现单线程管理多个channels,也就是可以管理多个网络链接。
    * 使用Selector的好处在于： **使用更少的线程来就可以来处理通道**了， 相比使用多个线程，避免了线程上下文切换带来的开销。

## IO多路复用

* select , poll, epoll
  * 单个proces就可以同时处理多个网络连接的IO
  * 不断轮询所负责的所有socket，当某个socket有数据到达，就通知用户进程
* 实际中对于每一个socket，一般都设置成NIO，但是整个用户的process其实是一直被block的，不过process是被block这个函数block，而不是被socket IO给Block
* IO多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的IO系统调用之上
* 通过把多个IO的阻塞复用到同一个select有阻塞上，从而使系统在单线程情况下，可以同时处理多个客户端请求

## 异步非阻塞AIO

* BIO在IO操作时开始阻塞应用程序，这意味着不可能同时重叠进行处理和IO操作
* NIO允许处理和IO操作重叠进行。但需要应用程序根据重现的规则来检查IO操作的状态
* AIO允许处理和IO操作重叠进行，包括IO操作完成的通知

# blocking与non-blocking区别

* blocling会一直block对应的进程直到操作完成
* non-blocking在kernel还准备数据的情况下立刻返回

# 同步IO与异步IO的区别

* 同步IO在 IO时会将process阻塞
  * BIO
  * NIO
    * 如果kernel数据没有准备好，这时不会block
    * 当kernel数据准备好的时候，将数据从内核拷贝到用户内存，为时进程被block
  * IO multiplexing
* 异步IO
  * 发起IO操作之后，直接返回，直到kernel发出信号，告诉进程IO完成



# IO多路复用

* 适用场合
  * 当处理多个描述符时
  * 一个客户处理多个套接口
  * 一个TCP服务器即要处理TCP，又要处理UDP



