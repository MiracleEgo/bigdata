# 为什么需要泛型

* 我只需要定义一次类，就可以被“任何”类型使用，而不是对每一种类型定义一个类
* 我的泛型只能保存我指明的类型，而不是放一堆object引用。

# 泛型通配符

> 泛型通配符在声明局部变量时是没有意义的.但当为一个方法声明一个参数时,是非常最要的

```properties
- ? 不确定的Java类型
- T(type) 具体的一个Java类型
- K V(key value) java键值中的Key Value
- E(element) 代表Element
```

* 上界通配符<? extends E>

  * 如果传入的类型不是E或者E的子类.编译不成功
  * 泛型中可以使用E的方法,否则还要强转成E才能使用

* 下界通配符<? super E>

  * 泛型中的参数必须是E或者E的父类

* ?与T的区别

  * 通过T确保泛型参数一致性

  * T可以多重限定

    ```java
    public static<T entends ClassA & ClassB> void test(T t)
    //T必须是A和B的公有子类型
    //t具有所限定的方法和属性
        //对于通配符?,因它不是一个确定的类型,所以不能多重限定
    ```

  * ?可以使用super限定

  ```java
  // 可以
  T t = operate();
  // 不可以
  ？ car = operate();
  ```


# [泛型擦除](https://juejin.im/post/5e61fb10e51d4526d6406cb0)

## 泛型擦除是什么？

* 这个所谓的泛型`T`最后会被转化为一个`Object`，最后又通过强制转化来进行一个转变。从这里我们也就能够知道为什么我们的数据从前面过来的时候，`String`类型数据能够直接被`Integer`进行接收了。

## [为什么要类型擦除？](http://www.pulpcode.cn/2017/12/30/why-java-generic-use-type-eraser/)

* 向后兼容。**java在一开始都是不支持泛型的**。为了让一个不支持泛型的语言支持泛型，只有两条路可以走，要么以前的非泛型容器保持不变，然后平行的增加一套泛型化的类型。要么直接把已有的非泛型容器扩展为泛型。不添加任何新的泛型版本。

* 避免JVM大换血，如果 JVM 将泛型类型延续到运行期，那么到运行期时 JVM 就需要进行大量的重构工作了，提高了运行期的效率。

为什么使用类型擦除就能保持向后兼容呢

* 我形象的理解为，之前非泛型的写法，编译成的虚拟机汇编码块是A，之后的泛型写法，只是在A的前面，后面“插入”了其它的汇编码，而并不会破坏A这个整体。这才算是既把非泛型“扩展为泛型”，又兼容了非泛型。

## 带来的问题

**（1） 强制类型转化**

这个问题的结果我们已经在上述文章中提及到了，通过反射的方式去进行插入的时候，我们的数据就会发生错误。

如果我们在一个`List<Integer>`中在不知情的情况下插入了一个`String`类型的数值，那这种重大错误，我们该找谁去说呢。

**（2）引用传递问题**

上面的问题中，我们已经说过了`T`将在后期被转义成`Object`，那我们对引用也进行一个转化，是否行得通呢？

```java
List<String> listObject = new ArrayList<Object>();
List<Object> listObject = new ArrayList<String>();
```

如果你这样写，在我们的检查阶段，会报错。但是从逻辑意义上来说，其实你真的有错吗？

**假设说我们的第一种方案是正确的**，那么其实就是将一堆`Object`数据存入，然后再由上面所说的强制转化一般，转化成`String`类型，听起来完全ok，因为在`List`中本来存储数据的方式就是`Object`。但其实是会出现`ClassCastException`的问题，因为`Object`是万物的基类，但是强转是为子类向父类准备的措施。

**再来假设说我们的第二种方案是正确的**，这个时候，根据上方的数据`String`存入，但是有什么意义存在呢？最后都还是要成`Object`的，你还不如就直接是`Object`。

## 解决方案

其实很简单，如果看过一些公开课想来就见过这样的用法。

```java
public class Part<T extends Parent> {

    private T val;

    public T getVal() {
        return val;
    }

    public void setVal(T val) {
        this.val = val;
    }
}

```

相比较于之前的`Part`而言，他多了`<T extends Parent>`的语句，==其实这就是将基类重新规划的操作，就算被编译，虚拟机也会知道将数据转化为`Parent`而不是直接用`Object`来直接进行替代==。

## 应用场景

* `<T extends Parent>`继承型