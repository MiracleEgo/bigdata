# [秒杀系统设计教程1](https://juejin.im/post/5dd09f5af265da0be72aacbd#heading-6)

# [秒杀系统架构分析与实战](https://www.jianshu.com/p/df4fbecb1a4b)

# 如何解决重复购买问题

* 联合主键不自增
  * `userId_phoneNum`

# [如何防止超卖(减库存设计)](https://cnsyear.com/posts/daf64fef.html)

* ##### 直接减库存

* ##### 支付成功减库存

* ##### 预扣库存(使用这个)

  * 用户下单后，库存为其保留一定的时间（如 10 分钟），超过这个时间，库存将会自动释放，释放后其他买家就可以继续购买。在用户付款前，系统会校验该订单的库存是否还有保留：如果没有保留，则再次尝试预扣；如果库存不足（也就是预扣失败）则不允许继续付款；如果预扣成功，则完成付款并实际地减去库存。
  * 针对恶意下单这种情况，虽然把有效的付款时间设置为 10 分钟，但是恶意买家完全可以在10分钟后再次下单，或者采用一次下单很多件的方式把库存减完。针对这种情况，解决办法还是要结合安全和反作弊的措施来制止。
  * 反作弊的措施：给经常下单不付款的买家进行识别打标（可以在被打标的买家下单时不减库存）、给某些类目设置最大购买件数（例如，参加活动的商品一人最多只能买 3件），以及对重复下单不付款的操作进行次数限制等。

# 若一个用户多次抢购同一件商品导致主键冲突报错怎么办

* 通过ignore实现主键冲突直接返回0表示该SQL执行失败

```sql
insert ignore into seckill_order(seckill_id,money,user_phone) values (....)
```

# redis缓存未更新问题

* 问题描述

  * 前端访问redis缓存，后端数据库修改后，前端未能更新

* 解决

  * 手动清空redis缓存

    ```redis
    flushall
    ```

# 如何防止链接暴露

* **接口防刷**，在高并发模式下，需单独开发一个方法保证用户抢购公平性
* **下单页面URL加入由服务器端生成的随机数作为参数，在秒杀开始的时候才能得到**。

**如何接口防刷**

* 首先要保证商品处于秒杀状态
  * 秒杀开始时间<当前时间，秒杀截止时间>当前时间
* 保证一个用户抢购到一件商品，同一用户只能有唯一的一个URL秒杀地址，不同用户间秒杀地址不同，且配合订单表`seckill_order`中联合主键配置实现

# 两个事务合并

* 减库存与记录购买明细 两个操作合并为一个接口方法：执行秒杀的操作
* 使用注解式事务
  * 保证事务方法的执行时间尽可能短
    * 不要穿插其他RPC/HTTP请求
  * 不是所有的方法都需要事务控制
    * 如只有一条修改的操作 ，只读操作是不需事务控制
  * Spring默认只对运行期异常进行事务回滚操作，对于编译异常是不回滚的
    * 尽量将编译期异常转为运行时异常



# 缓存一致性问题

* 先更新数据库再更新缓存
* 利用数据库的Binlog更新缓存

# 为何先记录订单再减少库存

* 优化sql操作，先记录会降低rowLock时间

# 如何降低update对rowLock的持有时间

* 执行一条update语句需要获得mysql的行锁rowLock
* 优化
  * 调用update和insert操作执行顺序	
    * 我们通过`insert ignore into xx`方式避免重复秒杀，先执行insert语句可以在插入时就排除可能存在重复秒杀的操作，这样就不用再执行更新操作了，在一定程度上降低了一倍的rowLock持有时间

# JMeter压测

* 当线程在5000个时，吞吐量为`602/sec `，根据`top`看到系统瓶颈在mysqld

# Redis压测

>  redis-benchmark -h 127.0.0.1 -p 6379 -c 100 -n 100000

* 10w请求完成时间0.69s，每秒QPS14w请求

# 高并发下唯一订单号生成

* 方案一

  * 使用` Java.Util`包下的UUID类`UUID.randomUUID().hashCode()`

* 方案二

  * 使用的是当前时间，包括毫秒数、纳秒数，不需要数据库参与计算，性能不用说。

  * ```java
    public static String genId(String machineId) {
            String orderId = machineId +
                            (System.currentTimeMillis() + "").substring(1) +
                            (System.nanoTime() + "").substring(7, 10);
            System.out.println(orderId);
            return orderId;
        }
    ```