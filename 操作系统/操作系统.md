# [进程的状态](https://blog.csdn.net/u012824097/article/details/52058395)

* 就绪状态
* 运行状态
* 阻塞状态

![img](https://i.loli.net/2020/07/26/ARq1t2N4s9hwaLc.png)

# [进程切换和线程切换的区别](https://www.cnblogs.com/lfri/p/12597297.html)

* 最主要的一个区别在于**进程切换涉及虚拟地址空间的切换而线程不会**。因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。

# [当前处理机状态]()

* 1、从硬件层看，是指处理机是在运行状态还是空闲状态；
* 2、从系统角度来看，是指处理机处于核心态还是处于用户态。

# [两个进程通信方式](https://www.jianshu.com/p/c1015f5ffa74)

## [管道](管道)

* 匿名管道通信
  - 管道是一种半双工的通信方式，数据只能**单向流动**，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指**父子进程关系**。
* 有名管道通信
  - 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信
* **管道的实质**
  * 管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，**管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据**。
  * 该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，==读出来以后在缓冲区就不复存在了==。
  * ==当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。==
* **管道的局限：**
  *  管道的主要局限性正体现在它的特点上：
    * 只支持单向数据流；
    * 只能用于具有亲缘关系的进程之间；
    * 没有名字；
    * 管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）；
    * 管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等；

## 共享内存(最高效)

- 使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。
- 为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。
- 由于多个进程共享一段内存**，因此需要依靠某种同步机制（如==信号量==）来达到进程间的同步及互斥**。

## 信号量

  - 信号量是一个**计数器**，用于多进程对共享数据的访问**，信号量的意图在于进程间同步。**
    为了获得共享资源，进程需要执行下列操作：
    （1）**创建一个信号量**：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。
    （2）**等待一个信号量**：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。
    （3）**挂出一个信号量**：该操作将信号量的值加1，也称为V操作。
    
## [套接字](https://www.jianshu.com/p/c1015f5ffa74)

  - 套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。
## 消息队列

- 消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。
- 与管道（无名管道：**只存在于内存中的文件**；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。
- 另外与管道不同的是，**消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达**。
- ==消息队列允许一个或多个进程向它写入与读取消息.==
- 管道和消息队列的通信数据都是先进先出的原则。

## 信号

  - 信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。
  
  - 如果该进程当前并未处于执行状态，则该信号就有内核保存起来，直该进程回复执行并传递给它为止。
  
  - 如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。
  
    ```properties
    Linux系统中常用信号：
    （1）SIGHUP：用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。
    （2）SIGINT：程序终止信号。程序运行过程中，按Ctrl+C键将产生该信号。
    （3）SIGQUIT：程序退出信号。程序运行过程中，按Ctrl+\\键将产生该信号。
    （4）SIGBUS和SIGSEGV：进程访问非法地址。
    （5）SIGFPE：运算中出现致命错误，如除零操作、数据溢出等。
    （6）SIGKILL：用户终止进程执行信号。shell下执行kill -9发送该信号。
    （7）SIGTERM：结束进程信号。shell下执行kill 进程pid发送该信号。
    （8）SIGALRM：定时器信号。
    （9）SIGCLD：子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。
    
    ```
  
    

# 线程间的通信方式

- 使用全局变量
  主要由于多个线程可能更改全局变量，因此全局变量最好声明为volatile
- 使用消息实现通信
  在Windows程序设计中，每一个线程都可以拥有自己的消息队列（UI线程默认自带消息队列和消息循环，工作线程需要手动实现消息循环），因此可以采用消息进行线程间通信sendMessage,postMessage。
- 使用事件CEvent类实现线程间通信
  Event对象有两种状态：有信号和无信号，线程可以监视处于有信号状态的事件，以便在适当的时候执行对事件的操作。

# 守护进程

* 守护进程
  * 一直在后台运行的进程，独立于终端并周期性执行某种任务
  * ==守护进程父进程是init进程，因它真正父进程在fork出子进程后就退出了，它是由init继承的孤儿进程==
  * 常见守护进程（通常以d结尾）
    * `mysqld`
    *  `syslogd`
    *  `httpd`
    * `sshd`

## 如何创建守护进程

* 基本概念
  * 进程组（process group）
    * 一个或多个进程的集合，每个进程都有一个进程组ID，此ID为进程组长进程ID
  * 会话期(session)
    * 每个会话有唯一一个会话首进程，会话ID为会话首进程ID
  * 控制终端
    * 每个会话可有一单独控制终端，与控制终端连接的会话首进程为控制进程
* 创建流程
  * `fork()`创建子进程，父进程`exit()`退出
    * 给shell终端造成程序已运行完毕假象，之后所有工作在子进程完成，形式上与终端脱离
  * 子进程中调用`setsid()`函数创建新会话
    * `setsid（）`
      * 摆脱原会话控制，该进程成为新会话期首进程
      * 摆脱原进程组，成为一个新进程组的组长
      * 摆脱终端控制，若该进程是一进程组组长，则返回错误
  * 再次`fork()`一个子进程并让父进程退出
  * 在子进程中调用`chdir()`，让根目录“/”成为子进程工作目录
  * 在子进程中调用`unmask()`，设置进程文件权限掩码为0
  * 在子进程中关闭不需要的文件描述符
  * 守护进程退出

# 僵尸进程

* 概念
  * 进程使用`fork`创建子进程，若子进程退出而父没调用`wait()或` `waitpid`获取子进程状态信息，那么子进程进程描述符会保存在系统中
* 危害
  * 若父进程不调用`wait()`或`waitpid()`，则子进程信息不会释放，子pid被占用，而系统pid有限，导致无法产生新进程
* 解决
  * 通过kill发送SIGTERM或SIGKILL信号

# 孤儿进程

* 概念
  * 每个进程退出时，内核释放进程所有资源，但保留一定信息，如进程号，退出状态，运行时间等，当一进程完成终止后，它父进程调用`wait()`或`waitpid()`系统调用获得子进程终止状态
  * 父进程退出而子进程还在运行，子进程将成为孤儿进程，被init进程(pid为1)收养并完成对他们状态的收集工作

# fork和wait有什么作用

* fork用来创建子进程
* wait 
  * 如果子进程状态已经改变 ，wait调用立即返回；否则调用wait进程将会阻塞直到有子进程改变状态或有信号来打断
    * 状态：子进程终止；子进程被一个信号终止；子进程被一个信号恢复
  * 父进程用来等待获取子进程状态信息，获取到以后清除掉子进程



# 内零头

内零头是指进程在向操作系统请求内存分配时，系统满足了进程所需要的内存需求后，还额外还多分了一些内存给该进程，**也就是说额外多出来的这部分内存归该进程所有，其他进程是无法访问的。**

* 页式
* 请求页式

# 外零头

外零头是指内存中存在着一些空闲的内存区域，**这些内存区域虽然不归任何进程所有，但是因为内存区域太小，无法满足其他进程所申请的内存大小而形成的内存零头。**

- 段式
- 请求段式存储管理

# [操作系统的调度策略](https://www.jianshu.com/p/ecfddbc0af2d)

## 时间片轮转调度[算法](https://link.jianshu.com/?t=http://lib.csdn.net/base/datastructure)（RR）

* 给每个进程固定的执行时间，根据进程到达的先后顺序让进程在单位时间片内执行，执行完成后便调度下一个进程执行，时间片轮转调度不考虑进程等待时间和执行时间，**属于抢占式调度**。
* 优点是**兼顾长短作业**；
* 缺点是**平均等待时间较长，上下文切换较费时**。适用于分时系统。

## 先来先服务调度算法（FCFS）

* 根据进程到达的先后顺序执行进程，**不考虑等待时间和执行时间**。属于非抢占式调度，
* 优点是**公平，实现简单**；
* 缺点是**不利于短作业**。CPU和I/O设备得不到充分利用

## 优先级调度算法（HPF）

* 在进程等待队列中选择优先级最高的来执行。

## 多级反馈队列调度算法

* **将时间片轮转与优先级调度相结合，把进程按优先级分成不同的队列，先按优先级调度，优先级相同的，按时间片轮转。**
* 优点是兼顾长短作业，有较好的响应时间，可行性强，适用于各种作业环境。

## 高响应比优先调度算法

* 根据“`响应比=（进程执行时间+进程等待时间）/ 进程执行时间`”这个公式得到的响应比来进行调度。高响应比优先算法在等待时间相同的情况下，作业执行的时间越短，响应比越高，满足段任务优先，同时响应比会随着等待时间增加而变大，优先级会提高，能够避免饥饿现象。
* 优点是兼顾长短作业，
* 缺点是计算响应比开销大，适用于批处理系统。

# [缺页中断](https://www.cnblogs.com/sunsky303/p/9214223.html)

* 缺页中断是硬中断
* 指的是当软件试图访问已映射在[虚拟](https://baike.baidu.com/item/虚拟)[地址空间](https://baike.baidu.com/item/地址空间)中，但是目前并未被加载在[物理内存](https://baike.baidu.com/item/物理内存)中的一个[分页](https://baike.baidu.com/item/分页)时，由[中央处理器](https://baike.baidu.com/item/中央处理器)的内存管理单元所发出的[中断](https://baike.baidu.com/item/中断)。

##  页面置换算法

* 进程运行过程中，如果发生缺页中断，而此时内存中有没有空闲的物理块是，为了能够把所缺的页面装入内存，系统必须从内存中选择一页调出到磁盘的对换区。但此时应该把那个页面换出，则需要根据一定的页面置换算法（Page Replacement Algorithm)来确定。

### 最佳置换（Optimal， OPT)

* ==置换以后不再被访问，或者在将来最迟才回被访问的页面，缺页中断率最低。==但是该算法需要依据以后各作业的使用情况，而当一个进程还未运行完成时，很难估计哪一个页面是以后不再使用或在最长时间以后才会用到的页面。**所以该算法是不能实现的**。但该算法仍然有意义，作为衡量其他算法优劣的一个标准。

### 先进先出置换算法（First In First Out, FIFO)

* 置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。**但是该算法会淘汰经常访问的页面，不适应进程实际运行的规律，目前已经很少使用**。

###  最近最久未使用置换算法（Least Recently Used， LRU）

* 置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。 
* LRU算法普偏地适用于各种类型的程序，但是系统要时时刻刻对各页的访问历史情况加以记录和更新，开销太大，因此LRU算法必须要有硬件的支持。

# [用户态和内核态](https://www.jianshu.com/p/85e931636f27)

* 内核态：**控制计算机的硬件资源，并提供上层应用程序运行的环境**。

* 用户态：**上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源**。

* 系统调用：**为了使上层应用能够访问到这些资源，内核为上层应用提供访问的接口。**

* 三者之间的关系如下：

  ![image-20200708201336648](https://i.loli.net/2020/07/08/w9GeTOcVCAPHo3u.png)
  
  

## 系统调用

* 系统调用是操作系统中的最小功能单位。
* 系统调用与上层应用程序的关系：
  * 如果将系统调用比作是一个“比画”，那么上层应用就是一个“汉字”。如果完成一个“汉字”，就需要通过多个系统调用。
* 系统调用与公用函数库的关系：
  * **公用函数库实现对系统调用的封装，将简单的业务逻辑接口呈现给用户，方便用户调用，从这个角度上看，库函数就像是组成汉字的“偏旁”**。

## [用户态切换到内核态的三种情况](https://www.jianshu.com/p/85e931636f27)

- 系统调用
  - **系统调用的本质其实也是中断**，相对于外围设备的硬中断，这种中断称为**软中断。**从触发方式和效果上来看，这三种切换方式是完全一样的，都相当于是执行了一个中断响应的过程。但是从触发的对象来看，**系统调用是进程主动请求切换的，而异常和硬中断则是被动的。**
- 异常事件：
  -  当CPU正在执行运行在用户态的程序时，突然发生某些预先不可知的异常事件，**这个时候就会触发从当前用户态执行的进程转向内核态执行相关的异常事件**，典型的如[缺页异常](https://link.jianshu.com/?t=http://www.cnblogs.com/jikexianfeng/articles/5647994.html)。
- 外围设备中断
  - 当外围设备完成用户的请求操作后，会像CPU发出中断信号，此时，**CPU就会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序**，**如果先前执行的指令是在用户态下，则自然就发生从用户态到内核态的转换**。

## 为什么要有用户态和内核态

* 限制不同程序之间的访问能力,防止一个程序获取别的程序的内存数据,或者获取外围设备的数据

# 内存管理

## [虚拟内存](https://blog.csdn.net/tennysonsky/article/details/45092229)

* **虚拟内存（Virtual Memory）**是指计算机呈现出要比实际拥有的内存大得多的内存量。因此他允许程式员编制并运行比实际系统拥有的内存大得多的程式。这使得许多大型项目也能够在具有有限内存资源的系统上实现。一个非常恰当的比喻是：你不必非常长的轨道就能让一列火车从上海开到北京。你只需要足够长的铁轨（比如说3公里）就能完成这个任务。采取的方法是把后面的铁轨即时铺到火车的前面，只要你的操作足够快并能满足需求，列车就能象在一条完整的轨道上运行。这也就是虚拟内存管理需要完成的任务。**有时我们也把逻辑地址称为 虚拟地址**。

* **人们之所以要创建一个虚拟地址空间，目的是为了解决进程地址空间隔离的问题**。但程序要想执行，必须运行在真实的内存上，所以，必须在虚拟地址与物理地址间建立一种映射关系。这样，通过映射机制，当程序访问虚拟地址空间上的某个地址值时，就相当于访问了物理地址空间中的另一个值。

## [页式存储管理](https://zhuanlan.zhihu.com/p/50919908)

### 基本思想

* 将内存空间分成大小相同的存储块，并按顺序编号（一般从0开始）。相应的将进程的逻辑地址空间分成若干个与内存块大小相等的块，但是为了方便区分，我们称为页。（**也就是说，在实际的内存中我们称为块，在逻辑地址中我们称为页**）。在为进程分配内存空间的时候，以页为单位进行。进程中若干个页分别**装入多个不相邻**的存储块中，通常，进程的最后一页通常装不满一个存储块，形成不可利用的碎片，称为页内碎片。

![img](https://i.loli.net/2020/07/24/6fQv31SLZ5dq2mY.jpg)

>  **图F中的11就是装载完毕后的页内碎片。**

### 页表

* 为了找到每个页所对应的存储块，**系统为每个进程建立一张索引表**，其中的每一项称为页表项，里面记录了相应页在内存中对应的物理块号。

![img](https://pic3.zhimg.com/80/v2-e5ffc46691fffe8b3e1c321d6c418aba_720w.jpg)

* 进程在执行时，通过查找页表，从而找到对应的物理块号，因此，**页表的作用就是实现从页号到块号的地址映射**。 此外，**操作系统还为每个进程建立了空闲块号，并从小到大进行排序。用来记录尚未分配的存储块的块号**。

### **页式存储的地址变换（重点）**

* 地址变换机构的任务，就是实现逻辑地址到物理地址之间的动态重定位。 因为进程的执行要装入内存，所以为了更方便快速的的找到对应的进程，页表绝大多数情况下是驻留在内存中的。因此，操作系统设置一个**页表寄存器，用来存放内存的起始地址跟页表的长度**。 当进程中的某个逻辑地址，被访问执行的时候，硬件逻辑地址变换结构会根据页的大小自动将有效的逻辑地址分成页号和页内偏移两部分：

![img](https://pic3.zhimg.com/80/v2-21e5442dcdf8ecdc3c4887c5ec207a3a_720w.jpg)

* 变换过程如下：

  1. 首先，页号与页表寄存器中的页表长度进行比较，若页号大于页表长度，则产生越界中断。（判越界）

  2. 否则，通过页表起始地址，找出页表。

  3. 根据页号，找出相应的页表项，得到该页的存储块号

  4. 根据块号与页内偏移，算出实际的物理地址。

  计算公式如下：

  ![img](https://pic2.zhimg.com/80/v2-9ae29edc893e399e777f0a731cbd04d1_720w.jpg)

* 页表通常是存在内存当中的所以CPU每存取一个数据的时候都需要**访问两次内存**。**第一次是访问内存中的页表，从而找到该页的存储块号，第二次才是真正的访问物理地址。**

### **二级分页**

* 对于难以找到连续的内存空间存放页表的问题，可将页表分页。按之前的思路，将**页表**依次编号。这样就可以将每一页都分别放在一个不同的存储体中。为了记录这些页在内存中的位置和存放情况，我们同样为离散分配的页表再建立一张页表，称之为外层页表。就像这样：

![img](https://pic4.zhimg.com/80/v2-b40b4e88444733562709512852ddb75b_720w.jpg)

* 例如，逻辑地址空间同样是32位，显然，每一页的大小为4KB。

* 如果采用的是一级页表，之前算过，光页表项就有1MB

* 如果采用的是二级页表，那么我们对页表再分页，这个时候，**外层页表的地址位数表示的是每页有多少个页表项，内层页号的地址数表示的就是有多少个这样的页表**

## [段式内存管理](https://www.cnblogs.com/edisonchou/p/5115242.html)

* 分页系统存在的一个无法容忍，同时也是分页系统无法解决的一个缺点就是：**一个进程只能占有一个虚拟地址空间**。在此种限制下，一个程序的大小至多只能和虚拟空间一样大，其所有内容都必须从这个共同的虚拟空间内分配。

* 分段管理就是**将一个程序按照逻辑单元分成多个程序段，每一个段使用自己单独的虚拟地址空间**。例如，对于编译器来说，我们可以给其5个段，占用5个虚拟地址空间，如下图所示：

  ![img](https://images2015.cnblogs.com/blog/381412/201601/381412-20160108234948996-410883841.jpg)

* 如此，**一个段占用一个虚拟地址空间，不会发生空间增长时碰撞到另一个段的问题，从而避免因空间不够而造成编译失败的情况**。如果某个数据结构对空间的需求超过整个虚拟之地所能够提供的空间，则编译仍将失败。不过出现这种可能的概率恐怕不会比太阳从西边出来的概率高出多少。

* 优点
  * 每个逻辑单元可单独占用一个虚拟地址空间，这样使得编写程序的空间大为增长。
  * 由于段式按逻辑关系划分，因此**共享起来十分方便**。
  * 对于空间稀疏的程序来说，**分段管理将节省大量的空间**。

* 缺点
  * 外部碎片和一个段必须全部加载到内存。
  * 那么，解决办法是什么呢？分页，不过这次的分页不是前面提到的直接对程序进程进行分页，**而是对程序里面的段进行分页，于是就形成了所谓的段页式内存管理模式**。

## [段页式内存管理](https://www.cnblogs.com/edisonchou/p/5115242.html)

* 段页式管理就是**将程序分为多个逻辑段，在每个段里面又进行分页，即将分段和分页组合起来使用**。这样做的目的就是想同时获得分段和分页的好处，但又避免了单独分段或单独分页的缺陷。
* 如果我们将每个段看做一个单独的程序，则逻辑分段就相当于同时加载多个程序。

### 段页式内存管理的实现

* 采用多级页表，顶级为段表，次级为页表。由段号在段表里面获得所应该使用的页表，然后在该页表里面查找物理页面号，如下图所示：**如果需要，次级页表又可以再分为两个或者多个层次，形成层次更为丰富的段页式层次结构**。

  ![img](https://images2015.cnblogs.com/blog/381412/201601/381412-20160109001322215-1012601308.jpg)

# [CPU高速缓存](https://blog.csdn.net/lbwo001/article/details/78817439)

* CPU高速缓存（英语：CPU Cache，在本文中简称缓存）是用于减少处理器访问内存所需平均时间的部件。在金字塔式存储体系中它位于自顶向下的第二层，仅次于CPU寄存 器。其容量远小于内存，但速度却可以接近处理器的频率。当处理器发出内存访问请求时，会先查看缓存内是否有请求数据。如果存在（命中），则不经访问内存直接返回该数据；如果不存在（失效），则要先把内存中的相应数据载入缓存，再将其返回处理器。
*    缓存从内存中抓取一般都是整个数据块，所以它的物理内存是连续的，几乎都是同行不同列的，而如果内循环以列的方式进行遍历的话，将会使整个缓存块无法被利用，而不得不从内存中读取数据，而从内存读取速度是远远小于从缓存中读取数据的。 

# [磁盘寻道算法](https://www.jianshu.com/p/a32a73f6956f)

* **先来先服务**
   公平且简单，但是没有对寻道进行优化，会降低设备的吞吐量，平均寻道时间较长
* **最短距离优先**
   每次寻道时间最短，但是不能保证平均寻道时间，而且在请求较多的时候，磁盘边缘可能会被无限期的延迟
* **电梯算法**
   磁盘指针向一侧进行读取，到边缘后反向读取，减少了平均时间，吞吐量达，但是由于是摆动，中间的机会要多于边缘磁盘
* **循环扫描**
   与电梯算法思想一致，不过是磁头每次都从一侧开始，使得机会平均

# [银行家算法](https://www.nowcoder.com/discuss/455369?type=2&channel=-2&source_id=discuss_terminal_discuss_jinghua)

当进程首次申请资源时，先测该进程需求的**最大资源数是否能被满足**，不满足就推迟分配。当进程在执行中继续申请资源时，**测试该进程占有的资源加上申请的资源是否大于系统最大资源**，大于则推迟分配，不大于则可以分配。  

- ​    可利用资源      
- ​    最大需求矩阵      
- ​    分配矩阵      
- ​    需求矩阵