# 守护进程

* 守护进程
  * 一直在后台运行的进程，独立于终端并周期性执行某种任务
  * 守护进程父进程是init进程，因它真正父进程在fork出子进程后就退出了，它是由init继承的孤儿进程
  * 常见守护进程（通常以d结尾）
    * `mysqld`
    *  `syslogd`
    *  `httpd`
    * `sshd`

## 如何创建守护进程

* 基本概念
  * 进程组（process group）
    * 一个或多个进程的集合，每个进程都有一个进程组ID，此ID为进程组长进程ID
  * 会话期(session)
    * 每个会话有唯一一个会话首进程，会话ID为会话首进程ID
  * 控制终端
    * 每个会话可有一单独控制终端，与控制终端连接的会话首进程为控制进程
* 创建流程
  * `fork()`创建子进程，父进程`exit()`退出
    * 给shell终端造成程序已运行完毕假象，之后所有工作在子进程完成，形式上与终端脱离
  * 子进程中调用`setsid()`函数创建新会话
    * `setsid（）`
      * 摆脱原会话控制，该进程成为新会话期首进程
      * 摆脱原进程组，成为一个新进程组的组长
      * 摆脱终端控制，若该进程是一进程组组长，则返回错误
  * 再次`fork()`一个子进程并让父进程退出
  * 在子进程中调用`chdir()`，让根目录“/”成为子进程工作目录
  * 在子进程中调用`unmask()`，设置进程文件权限掩码为0
  * 在子进程中关闭不需要的文件描述符
  * 守护进程退出

# 僵尸进程

* 概念
  * 进程使用`fork`创建子进程，若子进程退出而父没调用`wait()或` `waitpid`获取子进程状态信息，那么子进程进程描述符会保存在系统中
* 危害
  * 若父进程不调用`wait()`或`waitpid()`，则子进程信息不会释放，子pid被占用，而系统pid有限，导致无法产生新进程
* 解决
  * 通过kill发送SIGTERM或SIGKILL信号

# 孤儿进程

* 概念
  * 每个进程退出时，内核释放进程所有资源，但保留一定信息，如进程号，退出状态，运行时间等，当一进程完成终止后，它父进程调用`wait()`或`waitpid()`系统调用获得子进程终止状态
  * 父进程退出而子进程还在运行，子进程将成为孤儿进程，被init进程(pid为1)收养并完成对他们状态的收集工作

# fork和wait有什么作用

* fork用来创建子进程
* wait 
  * 如果子进程状态已经改变 ，wait调用立即返回；否则调用wait进程将会阻塞直到有子进程改变状态或有信号来打断
    * 状态：子进程终止；子进程被一个信号终止；子进程被一个信号恢复
  * 父进程用来等待获取子进程状态信息，获取到以后清除掉子进程



# 内零头

内零头是指进程在向操作系统请求内存分配时，系统满足了进程所需要的内存需求后，还额外还多分了一些内存给该进程，**也就是说额外多出来的这部分内存归该进程所有，其他进程是无法访问的。**

* 页式
* 请求页式

# 外零头

外零头是指内存中存在着一些空闲的内存区域，**这些内存区域虽然不归任何进程所有，但是因为内存区域太小，无法满足其他进程所申请的内存大小而形成的内存零头。**

- 段式
- 请求段式存储管理

# 用户态和内核态

## 为什么要有用户态和内核态

* 限制不同程序之间的访问能力,防止一个程序获取别的程序的内存数据,或者获取外围设备的数据

## 用户态切换到内核态

* 系统调用
* 异常
* 外围设备中断