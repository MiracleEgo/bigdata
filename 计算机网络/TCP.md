# IP寻址

* 本地网络寻址
  * A通过hosts将B计算机名转换为ip地址
  * 用自己的IP与子网掩码计算自己所处网段，比较B的IP与自己和子网掩码，发现处于相同网段
  * 在自己ARP缓存中查找是否有B的mac地址
  * 若没有，A启动ARP协议在本地网络arp广播来查询B的mac地址，获得后写入arp缓存
* 非本地网络寻址
  * A通过本机hosts或dns系统将B计算机名转为IP地址
  * 用自己IP与子网掩码计算自己网段与B比较，发现处于不同网段
  * A在自己arp缓存中查找是否有缺少网关（路由器本地接口）的MAC地址，若没找到则启动arp协议通过本地网络上的arp广播查询网关mac地址，获得后写入arp缓存表
  * 数据到达路由器后根据目的IP查找路由表，发送到下一跳路由，直到达到目的的的网络与主机

# TCP报文到达确认(ACK)机制

原文: <http://blog.csdn.net/wjtxt/article/details/6606022>

TCP数据包中的序列号（Sequence Number）不是以报文段来进行编号的，而是将连接生存周期内传输的所有数据当作一个字节流，序列号就是整个字节 流中每个字节的编号。一个TCP数据包中包含多个字节流的数据（即数据段），而且每个TCP数据包中的数据大小不一定相同。**在建立TCP连接的三次握手 过程中，通信双方各自已确定了初始的序号x和y，TCP每次传送的报文段中的序号字段值表示所要传送本报文中的第一个字节的序号。**

**TCP的报文到达确认（ACK），是对接收到的数据的最高序列号的确认，并向发送端返回一个下次接收时期望的TCP数据包的序列号（Ack Number）。**例如， 主机A发送的当前数据序号是400，数据长度是100，则接收端收到后会返回一个确认号是501的确认号给主机A。

**TCP提供的确认机制，可以在通信过程中可以不对每一个TCP数据包发出单独的确认包（Delayed ACK机制），而是在传送数据时，顺便把确认信息传出， 这样可以大大提高网络的利用率和传输效率。同时，TCP的确认机制，也可以一次确认多个数据报，例如，接收方收到了201，301，401的数据报，则只 需要对401的数据包进行确认即可，对401的数据包的确认也意味着401之前的所有数据包都已经确认，这样也可以提高系统的效率。**

**若发送方在规定时间内没有收到接收方的确认信息，就要将未被确认的数据包重新发送。接收方如果收到一个有差错的报文，则丢弃此报文，并不向发送方 发送确认信息。因此，TCP报文的重传机制是由设置的超时定时器来决定的，在定时的时间内没有收到确认信息，则进行重传。**这个定时的时间值的设定非 常重要，太大会使包重传的延时比较大，太小则可能没有来得及收到对方的确认包发送方就再次重传，会使网络陷入无休止的重传过程中。**接收方如果收到 了重复的报文，将会丢弃重复的报文，但是必须发回确认信息，否则对方会再次发送。**

TCP协议应当保证数据报按序到达接收方。

**如果接收方收到的数据报文没有错误，只是未按序号，这种现象如何处理呢**？TCP协议本身没有规定，而是由TCP 协议的实现者自己去确定。

通常有两种方法进行处理：

一是对没有按序号到达的报文直接丢弃，

二是将未按序号到达的数据包先放于缓冲区内，等待它前面 的序号包到达后，再将它交给应用进程。后一种方法将会提高系统的效率。

例如，发送方连续发送了每个报文中100个字节的TCP数据报，其序号分别是1， 101，201，…,701。假如其它7个数据报都收到了，而201这个数据报没有收到，则接收端应当对1和101这两个数据报进行确认，并将数据递交给相关的应用 进程，301至701这5个数据报则应当放于缓冲区，等到201这个数据报到达后，然后按序将201至701这些数据报递交给相关应用进程，并对701数据报进行 确认，确保了应用进程级的TCP数据的按序到达。

# [TCP三次握手](https://juejin.im/post/5b0119776fb9a07aaf357d77)

* 请求端(客户端)发起第一个SYN，执行主动打开，表示想要连接服务端，同时指明初始序号(ISN,比如这里的141553152)
  * ISN：初始序号，可以看做是一个32比特的计数器，每4ms加1，详见RFC 793

* 服务端做出回应，指明自己的初始序号，执行被动打开，同时将确认序号设置成对客户端的初始序号加1，表示确认了客户端的SYN

* 客户端将确认序号设置成服务端的初始序号加1，表示确认了服务端的SYN

---

* **第一次握手**
  * 主机A发送位码为syn＝1,随机产生seq number=x的数据包到服务器，主机B由SYN=1知道，A要求建立联机，此时状态为SYN_SENT； 
* **第二次握手**
  * 主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1),SYN=1,ACK=1,随机产生seq=y的包，此时状态由LISTEN变为SYN_RECV； 
* **第三次握手**
  * 主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功，双方状态ESTABLISHED。

完成三次握手，主机A与主机B开始传送数据

## 为什么两次就建立连接还要三次握手呢？

* 双方初始化Sequence num 值,两

* 防止已失效的连接请求报文又突然传递服务器。

  * 所谓“防止已失效的连接请求报文又突然传递服务器。”是这样一种情况： 

    A客户端发出连接请求，因为连接请求报文丢失而未等到确认。于是A再次重传了连接请求，建立了连接。数据传输完毕后，释放了连接。现在假设那第一个请求只是因为网路节点长时间滞留了，使得它在第二个连接释放后才到达B服务器，那么B会以为这是一个新的连接请求，于是就向A发了个连接确认，注意了：如果没有最后一次的确认B会一厢情愿的以为连接已经建立，可人家A同学一看那个B给的是什么呀！跟自己没关系，简单粗暴的丢掉。这时B孩子还傻傻的等着A给他发数据，就这样，B白白浪费的大把的时光和资源。 

    那B会一直傻等吗？当然不是，它的等待也是有限的，答案就是保活计时器。

## 建立连接时如果超时了会发生什么事情？

* ![img](https://user-gold-cdn.xitu.io/2018/5/20/1637cd24649647a6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

* 服务器在客户端建立连接时刚好断电。可以看出客户端进行了重试，但是重试之间的时间间隔第一次是5.81秒，而第二次间隔是24.00秒。

## 异常终止连接会发生什么事情？

* 连接一方发送复位报文来中途释放连接【正常是发送FIN】
* 异常释放的一端将返回RST报文段，收到的一方将终止连接，并通知应用层进行复位，接收方并不对RST报文进行确认。

## [SYN泛洪攻击](https://www.cnblogs.com/sunsky303/p/11811097.html)

* 攻击者发送大量的SYN包，服务器回应(SYN+ACK)包，但是攻击者不回应ACK包，**这样的话，服务器不知道(SYN+ACK)是否发送成功，默认情况下会重试5次（tcp_syn_retries**）。这样的话，对于服务器的内存，带宽都有很大的消耗。
* 攻击者如果处于公网，可以伪造IP的话，对于服务器就很难根据IP来判断攻击者，给防护带来很大的困难。
* 防御
  * 防火墙禁止掉部分IP
  * 限制SYN并发数量、超时时间
    * 增大tcp_max_syn_backlog
      * 在内核里有个队列用来存放还没有确认ACK的客户端请求，当等待的请求数大于tcp_max_syn_backlog时，后面的会被丢弃。
    * 减小tcp_synack_retries
      * 把tcp_synack_retries设置为0或者1。因为对于正常的客户端，如果它接收不到服务器回应的ACK包，它会再次发送SYN包，客户端还是能正常连接的，只是可能在某些情况下建立连接的速度变慢了一点
    * 启用tcp_syncookies
      * 当启用tcp_syncookies时，backlog满了后，linux内核生成一个特定的n值，而不并把客户的连接放到半连接的队列backlog里（即没有存储任何关于这个连接的信息，不浪费内存）。当客户端提交第三次握手的ACK包时，linux内核取出n值，进行校验，如果通过，则认为这个是一个合法的连接。

# TCP四次挥手

![深度截图_选择区域_20190609112731.png](https://i.loli.net/2019/06/09/5cfc7cb4489e369847.png)

1. 请求端(客户端)想断开连接，于是发出一个FIN包
2. 服务端接收到请求，在确认序号上对客户端的序号加1表示已确认
3. 服务端关闭自己的连接，发出一个FIN包
4. 客户端接收到请求，在确认序号上对服务端序号加1表示已经确认

---

1. 第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；
2. 第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number(**ack**)为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；
3. 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；
4. 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。

* 简化版
  * Client -> FIN  -> Server   
  * Client <- ACK  <- Server   这时候Client端处于FIN_WAIT_2状态；而Server 程序处于CLOSE_WAIT状态。   
  * Client <- FIN  <- Server   这时Server 发送FIN给Client，Server 就置为LAST_ACK状态。   
  * Client -> ACK  -> Server   Client回应了ACK，那么Server 的套接字才会真正置为CLOSED状态。    

## **为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？**

* 因为全双工,发送方和接收方都需要FIN报文和ACK报文

* 这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后**，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。**

  但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。

## [何时处于CLOSE_WAIT状态](https://blog.csdn.net/dj0379/article/details/61416189)

* 在被动关闭连接情况下，在已经接收到FIN，但还没有发送自己的FIN时刻，连接处于CLOSE_WAIT状态

## 服务器出现大量CLOSE_WAIT状态的原因

* Server处于CLOSE_WAIT状态时说明还未发FIN给Client,可能在关闭连接之前还有一些事情要做
  * 对方关闭socket连接,我方忙于读或写,没有关闭连接
    * 检查代码,特别是释放资源的代码
    * 检查配置,特别是处理请求的线程配置
* 通常一个CLOSE_WAIT会持续至少2小时，造成资源浪费

## 为什么要有四次挥手的TIME_WAIT的状态 

* 保证最后一个的一个ACK报文能到达B**。**
  
  * **这个ACK报文有可能丢失，因而使得处在LAST_ACK状态得不到对已发送的FIN+ACK报文的确认，**B会超时重传这个FIN+ACk ,而A就能在这TIME_WAIT时间（2MSL）里收到这个重传的报文，A就可以重传一次确认，如果没有这个TIME_WAIT， 那B重传的FIN_ACK，可A早就走了，自然不会再重发确认，这样B就无法按照正常步骤进入CLOSE 状态。 
  
    > *RFC 793*中规定*MSL*为*2*分钟，实际应用中常用的是*30*秒，*1*分钟和*2*分钟等。
* 防止“**已失效的报文连接请求**”
  
  * A在TIME_WAIT中，经过这2MSL的时间，就可以使本链接持续的时间内产生的所有连接消失，**这样就可以使下一个新的连接中不会出现这样旧的连接请求报文段**。 
* **谁先关闭谁就有一个TIME_WAIT的状态；**


在linux的网络编程中，如果服务器如果先关闭，你会发现，现在想要立马再次启动服务器，就会报错说这个端口号被占用着，那就是因为有这个TIME_WAIT，2msl（**Maximum Segment Lifetime==>报文最大生存时间**）的时间.那么怎么解决 ？ 

解决：setsockopt（）函数。在这就不多说了。

# [流量控制](https://juejin.im/post/5d7ed78c518825250177933e)

## 滑动窗口

* 数据的传送过程中很可能出现接收方来不及接收的情况，这时就需要对发送方进行控制以免数据丢失。利用滑动窗口机制可以很方便地在TCP连接上对发送方的流量进行控制。**TCP的窗口单位是字节，不是报文段，发送方的发送窗口不能超过接收方给出的接收窗口的数值。**

### 持续计时器

* 存在这样一种情况：发送方接收到零窗口报文之后将发送窗口设置为0，停止发送数据。但等到接收方有足够缓存，发送了非零窗口大小的报文，但是这个报文中途丢失，那么发送方的发送窗口就一直为0导致死锁。
* 为此，TCP为每一个连接设有一个持续计时器(Persistence Timer)：当TCP连接的一方收到对方的零窗口通知时就启动持续计时器。若持续计时器时间到期，就发送一个零窗口探测报文段(携有1字节的数据)，那么收到这个报文段的一方就在确认这个探测报文段时给出了现在的窗口值。若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器；若窗口不是零，则死锁的僵局就可以打破了。

## 延迟ACK

* 如果TCP对每个数据包都发送一个ACK确认，那么只是一个单独的数据包为了发送一个ACK代价比较高，所以TCP会延迟一段时间，如果这段时间内有数据发送到对端，则捎带发送ACK，如果在延迟ACK定时器触发时候，发现ACK尚未发送，则立即单独发送；

* 延迟ACK好处：
  * 避免糊涂窗口综合症。
  * 发送数据的时候将ACK捎带发送，不必单独发送ACK。如果延迟时间内有多个数据段到达，那么允许协议栈发送一个ACK确认多个报文段。减少流量消耗。

# [拥塞控制](https://juejin.im/post/5d7ed78c518825250177933e)

## 慢启动

* 开始发送方先设置cwnd=1，发送第一个报文段M1，接收方接收到M1后，ACK返回给发送端，发送端将cwnd增加到2，接着发送方发送M2，再次接受到ACK后将cwnd增加到4...<span style="color:red">慢启动算法每经过一个传输轮次，拥塞窗口cwnd就加倍。</span>
* 当rwnd足够大时，为防止拥塞窗口cwind的增长引起网络拥塞，还需要另外一个变量，慢开始门限ssthresh
* **当cwnd＜ssthresh，使用慢开始算法** 
* **当cwnd=ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法** 
* **当cwnd＞ssthresh，使用拥塞避免算法**

## 拥塞避免

* 控制过程:
  1. TCP连接初始化，将拥塞窗口cwnd设置为1个报文段，即cwnd=1
  2. 执行慢开始算法，cwnd按指数规律增长，直到cwnd == ssthresh时，开始拥塞避免算法，cwnd按线性规律增长
  3. 当网络发生阻塞，把ssthresh值更新为拥塞前cwnd的一半(12=24/2)，cwnd重新设置为1，再按照(2)执行
  4. **让拥塞窗口cwnd缓慢地增大，每经过一个往返时间RTT就把发送方的拥塞窗口cwnd+1，而不是加倍**。这样拥塞窗口cwnd线性缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢地多。
  
  ![TCP拥塞控制](https://user-gold-cdn.xitu.io/2019/9/16/16d3779f0be09f71?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 快重传

* 当TCP源端收到3个相同的ACK确认时，即认为有数据包丢失，则源端重传丢失的数据包，而不必等待RTO(Retransmission Timeout)超时。由于发送方尽早重传未被确认的报文段。因此，采用快重传后可以使整个网络吞吐量提高20%

## 快恢复

* 快恢复算法控制过程:
  *  当发送方连续收到3个重复确认时，发**送方认为网络很可能没有发生拥塞，因此不执行慢启动**。**而是把cwnd值设为新的门限值，然后执行拥塞避免算法，cwnd值线性增大**，避免了当网络拥塞不够严重时采用"慢启动"算法而造成过大地减小发送窗口尺寸的现象，这就是快恢复。
  * ![TCP快恢复](https://user-gold-cdn.xitu.io/2019/9/16/16d3779f5a10efb7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

* 拥塞控制三种动作
  * 收到一新确认，网络正常
    * 此时增加单次发送量
      * 若单次发送量小于倍增阈值，发送量X2，指数增
      * 否则发送量+1，线性增
  * 收到三条重复确认，网络繁忙
    * 单次发送量减半，倍增阈值=单次发送量（进入线性增长期）
  * 确认未收到，超时。网络更加繁忙
    * 倍增阈值=单次发送量/2，单次发送量=1

* TCP的AIMD（加性增窗、乘性减窗）策略

  ```c
  While(Sending_Not_Finish){
  	if(Not_Loss_Packet){
  		CongWin++;
  	}else
  		CongWin=[CongWin/2]; //[]的意思是取整
  }
  ```

  

# 可靠性传输-差错控制

* 检验和
  * 每个报文段有16位检验和，若检验和无效，则由终点TCP挂失报文。
* 确认   
  * 积累确认（ACK）
    *   接收方通告期望接收下一节点seqnum，忽略失序到达报文。
    * 在TCP首部的32位ACK字段用于积累确认，它的值仅在ACK标志为1时才有效
  * 选择确认（SACK`selective acknowledgment`）
    * SACK要报告失序的数据块及重复的报文段
  * 产生确认的情况
* 重传（差错控制核心）
  * 一个报文段发送时，会被保存到一个队列中，直至被确认为止
  * 重传计时器超时或发送方收到一报文段三个重复ACK，该报文段重传​
  * 类型
    * RTO重传（超时重传）
      * 发送方TCP计时器时间到，TCP发送队列最前面报文段（序列号最小），并重启计时器
      * RTO值是动态的，根据报文段的往返时间（RTT）更新
    * 三个重复的ACK报文段（快重传）
      * 若某报文段有3个重复确认，立即重传并重启RTO计时器，而不用等待计时器超时
* [ARQ协议](https://mp.weixin.qq.com/s/-DZj158-LOQmnCayf1_n3A)
  * 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
* 其它
  * TCP不会将失序到达报文段丢了，会暂时保存并标为失序，直至失序报文段到齐

# 子网掩码的计算及与子网数、主机数关系

子网掩码是一个32位地址，是与IP地址结合使用的一种技术。它的主要作用有两个，**一是用于屏蔽IP地址的一部分以区别**[**网络标识**](http://baike.baidu.com/view/1120331.htm)**和**[**主机**](http://baike.baidu.com/view/23880.htm)**标识，并说明该IP地址是在**[**局域网**](http://baike.baidu.com/view/788.htm)**上，还是在远程网上。二是用于将一个大的IP网络划分为若干小的子网络。**

 使用子网是为了减少IP的浪费。因为随着互联网的发展，越来越多的网络产生，有的网络多则几百台，有的只有区区几台，这样就浪费了很多IP地址，所以要划分子网。使用子网可以提高网络应用的效率。

通过IP 地址的二进制与子网掩码的二进制进行与运算，确定某个设备的网络地址和主机号，也就是说通过子网掩码分辨一个网络的网络部分和主机部分。子网掩码一旦设置，网络地址和主机地址就固定了。

1、利用子网数目计算子网掩码

把B类地址172.16.0.0划分成30个子网络，它的子网掩码是多少？

①将子网络数目30转换成二进制表示11110

②统计一下这个二进制的数共有5位

③注意：当二进制数中只有一个1的时候，所统计的位数需要减1（例如：10000要统计为4位）

④将B类地址的子网掩码255.255.0.0主机地址部分的前5位变成1

⑤这就得到了所要的子网掩码（11111111.11111111.11111000.00000000）255.255.248.0。

# DHCP工作过程的六个主要步骤

DHCP分为两个部分：一个是服务器端，另一个是客户端。

所有客户机的IP地址设定资料都由DHCP服务器集中管理，并负责处理客户端的DHCP请求；而客户端则会使用从服务器分配下来的IP地址。

## 1. DHCP服务器IP分配方式

DHCP服务器提供三种IP分配方式：

- 自动分配（Automatic Allocation） 自动分配是当DHCP客户端第一次成功地从DHCP服务器端分配到一个IP地址之后，就永远使用这个地址。
- 动态分配（Dynamic Allocation） 动态分配是当DHCP客户端第一次从DHCP服务器分配到IP地址后，并非永久地使用该地址，每次使用完后，DHCP客户端就得释放这个IP地址，以给其他客户端使用。
- 手动分配 手动分配是由DHCP服务器管理员专门为客户端指定IP地址。

## 2. DHCP服务工作流程

## 

![img](https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=d19ffbc2d21373f0e13267cdc566209e/5ab5c9ea15ce36d3d5e5e08939f33a87e850b1a1.jpg)

1. DHCP Client以广播的方式发出DHCP Discover报文。

2. 所有的DHCP Server都能够接收到DHCP Client发送的DHCP Discover报文，所有的DHCP Server都会给出响应，向DHCP Client发送一个DHCP Offer报文。

   DHCP Offer报文中“Your(Client) IP Address”字段就是DHCP Server能够提供给DHCP Client使用的IP地址，且DHCP Server会将自己的IP地址放在“option”字段中以便DHCP Client区分不同的DHCP Server。DHCP Server在发出此报文后会存在一个已分配IP地址的纪录。

3. DHCP Client只能处理其中的一个DHCP Offer报文，一般的原则是DHCP Client处理最先收到的DHCP Offer报文。

   DHCP Client会发出一个广播的DHCP Request报文，在选项字段中会加入选中的DHCP Server的IP地址和需要的IP地址。

4. DHCP Server收到DHCP Request报文后，判断选项字段中的IP地址是否与自己的地址相同。如果不相同，DHCP Server不做任何处理只清除相应IP地址分配记录；如果相同，DHCP Server就会向DHCP Client响应一个DHCP ACK报文，并在选项字段中增加IP地址的使用租期信息。

5. DHCP Client接收到DHCP ACK报文后，检查DHCP Server分配的IP地址是否能够使用。如果可以使用，则DHCP Client成功获得IP地址并根据IP地址使用租期自动启动续延过程；如果DHCP Client发现分配的IP地址已经被使用，则DHCP Client向DHCPServer发出DHCP Decline报文，通知DHCP Server禁用这个IP地址，然后DHCP Client开始新的地址申请过程。

6. DHCP Client在成功获取IP地址后，随时可以通过发送DHCP Release报文释放自己的IP地址，DHCP Server收到DHCP Release报文后，会回收相应的IP地址并重新分配。

# ICMP Internet控制[报文](https://baike.baidu.com/item/%E6%8A%A5%E6%96%87/3164352)协议

ICMP是（Internet Control Message Protocol）Internet控制[报文](https://baike.baidu.com/item/%E6%8A%A5%E6%96%87/3164352)协议。它是[TCP/IP协议簇](https://baike.baidu.com/item/TCP%2FIP%E5%8D%8F%E8%AE%AE%E7%B0%87)的一个子协议，用于在IP[主机](https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/455151)、[路由](https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1)器之间传递控制消息。控制消息是指[网络通](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%9A)不通、[主机](https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/455151)是否可达、[路由](https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1/363497)是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。

# 服务器常用端口及作用

* 21 FTP
* 23 TELNET
* 25 SMTP
* 80 HTTP
* 3306 MYSQL

# 网络编程中,需要调用哪些函数

* 客户端
  * connect() 连接服务器
  * send() 发送消息
  * close() 关闭socket
* 服务端
  * bind() 绑定端口
  * listen() 监听端口
  * accept() 接收连接
  * recv() 接收消息
  * close() 关闭socket

# [TCP/IP协议栈分几层](https://blog.csdn.net/Mary19920410/article/details/61931234)

![img](https://img-blog.csdn.net/20170313215505756)

* 应用层
  * FTP,SMTP HTTP
* 传输层
  * TCP UDP
* 网络层
  * ICMP IGMP
* 网络接口层(物理层+链路层)
  * ARP