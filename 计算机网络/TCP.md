# [TCP三次握手](https://juejin.im/post/5b0119776fb9a07aaf357d77)

* 请求端(客户端)发起第一个SYN，执行主动打开，表示想要连接服务端，同时指明初始序号(ISN,比如这里的141553152)
  * ISN：初始序号，可以看做是一个32比特的计数器，每4ms加1，详见RFC 793

* 服务端做出回应，指明自己的初始序号，执行被动打开，同时将确认序号设置成对客户端的初始序号加1，表示确认了客户端的SYN

* 客户端将确认序号设置成服务端的初始序号加1，表示确认了服务端的SYN

---

* **第一次握手**
  * 主机A发送位码为syn＝1,随机产生seq number=x的数据包到服务器，主机B由SYN=1知道，A要求建立联机，此时状态为SYN_SENT； 
* **第二次握手**
  * 主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1),SYN=1,ACK=1,随机产生seq=y的包，此时状态由LISTEN变为SYN_RECV； 
* **第三次握手**
  * 主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功，双方状态ESTABLISHED。

完成三次握手，主机A与主机B开始传送数据

## 为什么两次就建立连接还要三次握手呢？

* 双方初始化Sequence num 值,两

* 防止已失效的连接请求报文又突然传递服务器。

  * 所谓“防止已失效的连接请求报文又突然传递服务器。”是这样一种情况： 

    A客户端发出连接请求，因为连接请求报文丢失而未等到确认。于是A再次重传了连接请求，建立了连接。数据传输完毕后，释放了连接。现在假设那第一个请求只是因为网路节点长时间滞留了，使得它在第二个连接释放后才到达B服务器，那么B会以为这是一个新的连接请求，于是就向A发了个连接确认，注意了：如果没有最后一次的确认B会一厢情愿的以为连接已经建立，可人家A同学一看那个B给的是什么呀！跟自己没关系，简单粗暴的丢掉。这时B孩子还傻傻的等着A给他发数据，就这样，B白白浪费的大把的时光和资源。 

    那B会一直傻等吗？当然不是，它的等待也是有限的，答案就是保活计时器。

## 建立连接时如果超时了会发生什么事情？

* ![img](https://user-gold-cdn.xitu.io/2018/5/20/1637cd24649647a6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

* 服务器在客户端建立连接时刚好断电。可以看出客户端进行了重试，但是重试之间的时间间隔第一次是5.81秒，而第二次间隔是24.00秒。

## 异常终止连接会发生什么事情？

* 连接一方发送复位报文来中途释放连接【正常是发送FIN】
* 异常释放的一端将返回RST报文段，收到的一方将终止连接，并通知应用层进行复位，接收方并不对RST报文进行确认。

## [SYN泛洪攻击](https://www.cnblogs.com/sunsky303/p/11811097.html)

* 攻击者发送大量的SYN包，服务器回应(SYN+ACK)包，但是攻击者不回应ACK包，**这样的话，服务器不知道(SYN+ACK)是否发送成功，默认情况下会重试5次（tcp_syn_retries**）。这样的话，对于服务器的内存，带宽都有很大的消耗。
* 攻击者如果处于公网，可以伪造IP的话，对于服务器就很难根据IP来判断攻击者，给防护带来很大的困难。
* 防御
  * 防火墙禁止掉部分IP
  * 限制SYN并发数量、超时时间
    * 增大tcp_max_syn_backlog
      * 在内核里有个队列用来存放还没有确认ACK的客户端请求，当等待的请求数大于tcp_max_syn_backlog时，后面的会被丢弃。
    * 减小tcp_synack_retries
      * 把tcp_synack_retries设置为0或者1。因为对于正常的客户端，如果它接收不到服务器回应的ACK包，它会再次发送SYN包，客户端还是能正常连接的，只是可能在某些情况下建立连接的速度变慢了一点
    * 启用tcp_syncookies
      * 当启用tcp_syncookies时，backlog满了后，linux内核生成一个特定的n值，而不并把客户的连接放到半连接的队列backlog里（即没有存储任何关于这个连接的信息，不浪费内存）。当客户端提交第三次握手的ACK包时，linux内核取出n值，进行校验，如果通过，则认为这个是一个合法的连接。

# TCP四次挥手

![深度截图_选择区域_20190609112731.png](https://i.loli.net/2019/06/09/5cfc7cb4489e369847.png)

1. 请求端(客户端)想断开连接，于是发出一个FIN包
2. 服务端接收到请求，在确认序号上对客户端的序号加1表示已确认
3. 服务端关闭自己的连接，发出一个FIN包
4. 客户端接收到请求，在确认序号上对服务端序号加1表示已经确认

---

1. 第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；
2. 第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number(**ack**)为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；
3. 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；
4. 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。

* 简化版
  * Client -> FIN  -> Server   
  * Client <- ACK  <- Server   这时候Client端处于FIN_WAIT_2状态；而Server 程序处于CLOSE_WAIT状态。   
  * Client <- FIN  <- Server   这时Server 发送FIN给Client，Server 就置为LAST_ACK状态。   
  * Client -> ACK  -> Server   Client回应了ACK，那么Server 的套接字才会真正置为CLOSED状态。    

## **为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？**

* 因为全双工,发送方和接收方都需要FIN报文和ACK报文

* 这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后**，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。**

  但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。

## [何时处于CLOSE_WAIT状态](https://blog.csdn.net/dj0379/article/details/61416189)

* 在被动关闭连接情况下，在已经接收到FIN，但还没有发送自己的FIN时刻，连接处于CLOSE_WAIT状态

## 服务器出现大量CLOSE_WAIT状态的原因

* Server处于CLOSE_WAIT状态时说明还未发FIN给Client,可能在关闭连接之前还有一些事情要做
  * 对方关闭socket连接,我方忙于读或写,没有关闭连接
    * 检查代码,特别是释放资源的代码
    * 检查配置,特别是处理请求的线程配置
* 通常一个CLOSE_WAIT会持续至少2小时，造成资源浪费

## 为什么要有四次挥手的TIME_WAIT的状态 

* 保证最后一个的一个ACK报文能到达B**。**
  
  * **这个ACK报文有可能丢失，因而使得处在LAST_ACK状态得不到对已发送的FIN+ACK报文的确认，**B会超时重传这个FIN+ACk ,而A就能在这TIME_WAIT时间（2MSL）里收到这个重传的报文，A就可以重传一次确认，如果没有这个TIME_WAIT， 那B重传的FIN_ACK，可A早就走了，自然不会再重发确认，这样B就无法按照正常步骤进入CLOSE 状态。 
  
    > *RFC 793*中规定*MSL*为*2*分钟，实际应用中常用的是*30*秒，*1*分钟和*2*分钟等。
* 防止“**已失效的报文连接请求**”
  
  * A在TIME_WAIT中，经过这2MSL的时间，就可以使本链接持续的时间内产生的所有连接消失，**这样就可以使下一个新的连接中不会出现这样旧的连接请求报文段**。 
* **谁先关闭谁就有一个TIME_WAIT的状态；**


在linux的网络编程中，如果服务器如果先关闭，你会发现，现在想要立马再次启动服务器，就会报错说这个端口号被占用着，那就是因为有这个TIME_WAIT，2msl（**Maximum Segment Lifetime==>报文最大生存时间**）的时间.那么怎么解决 ？ 

解决：setsockopt（）函数。在这就不多说了。

# [流量控制](https://juejin.im/post/5d7ed78c518825250177933e)

## 滑动窗口

* 数据的传送过程中很可能出现接收方来不及接收的情况，这时就需要对发送方进行控制以免数据丢失。利用滑动窗口机制可以很方便地在TCP连接上对发送方的流量进行控制。**TCP的窗口单位是字节，不是报文段，发送方的发送窗口不能超过接收方给出的接收窗口的数值。**

### 持续计时器

* 存在这样一种情况：发送方接收到零窗口报文之后将发送窗口设置为0，停止发送数据。但等到接收方有足够缓存，发送了非零窗口大小的报文，但是这个报文中途丢失，那么发送方的发送窗口就一直为0导致死锁。
* 为此，TCP为每一个连接设有一个持续计时器(Persistence Timer)：当TCP连接的一方收到对方的零窗口通知时就启动持续计时器。若持续计时器时间到期，就发送一个零窗口探测报文段(携有1字节的数据)，那么收到这个报文段的一方就在确认这个探测报文段时给出了现在的窗口值。若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器；若窗口不是零，则死锁的僵局就可以打破了。

## 延迟ACK

* 如果TCP对每个数据包都发送一个ACK确认，那么只是一个单独的数据包为了发送一个ACK代价比较高，所以TCP会延迟一段时间，如果这段时间内有数据发送到对端，则捎带发送ACK，如果在延迟ACK定时器触发时候，发现ACK尚未发送，则立即单独发送；

* 延迟ACK好处：
  * 避免糊涂窗口综合症。
  * 发送数据的时候将ACK捎带发送，不必单独发送ACK。如果延迟时间内有多个数据段到达，那么允许协议栈发送一个ACK确认多个报文段。减少流量消耗。

# [拥塞控制](https://juejin.im/post/5d7ed78c518825250177933e)

## 慢启动

* 开始发送方先设置cwnd=1，发送第一个报文段M1，接收方接收到M1后，ACK返回给发送端，发送端将cwnd增加到2，接着发送方发送M2，再次接受到ACK后将cwnd增加到4...<span style="color:red">慢启动算法每经过一个传输轮次，拥塞窗口cwnd就加倍。</span>
* 当rwnd足够大时，为防止拥塞窗口cwind的增长引起网络拥塞，还需要另外一个变量，慢开始门限ssthresh
* **当cwnd＜ssthresh，使用慢开始算法** 
* **当cwnd=ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法** 
* **当cwnd＞ssthresh，使用拥塞避免算法**

## [拥塞避免](https://zhuanlan.zhihu.com/p/76023663)

* 控制过程:
  1. TCP连接初始化，将拥塞窗口cwnd设置为1个报文段，即cwnd=1
  2. 执行慢开始算法，cwnd按指数规律增长，直到cwnd == ssthresh时，开始拥塞避免算法，cwnd按线性规律增长
  3. 当网络发生阻塞，把ssthresh值更新为拥塞前cwnd的一半(12=24/2)，cwnd重新设置为1，再按照(2)执行
  4. **让拥塞窗口cwnd缓慢地增大，每经过一个往返时间RTT就把发送方的拥塞窗口cwnd+1，而不是加倍**。这样拥塞窗口cwnd线性缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢地多。
  
  ![TCP拥塞控制](https://user-gold-cdn.xitu.io/2019/9/16/16d3779f0be09f71?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 快重传

* 当TCP源端收到3个相同的ACK确认时，即认为有数据包丢失，则源端重传丢失的数据包，而不必等待RTO(Retransmission Timeout)超时。由于发送方尽早重传未被确认的报文段。因此，采用快重传后可以使整个网络吞吐量提高20%

## 快恢复

* 快恢复算法控制过程:
  *  当发送方连续收到3个重复确认时，发**送方认为网络很可能没有发生拥塞，因此不执行慢启动**。**而是把cwnd值设为新的门限值，然后执行拥塞避免算法，cwnd值线性增大**，避免了当网络拥塞不够严重时采用"慢启动"算法而造成过大地减小发送窗口尺寸的现象，这就是快恢复。
  * ![TCP快恢复](https://user-gold-cdn.xitu.io/2019/9/16/16d3779f5a10efb7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

* 拥塞控制三种动作
  * 收到一新确认，网络正常
    * 此时增加单次发送量
      * 若单次发送量小于倍增阈值，发送量X2，指数增
      * 否则发送量+1，线性增
  * 收到三条重复确认，网络繁忙
    * 单次发送量减半，倍增阈值=单次发送量（进入线性增长期）
  * 确认未收到，超时。网络更加繁忙
    * 倍增阈值=单次发送量/2，单次发送量=1

* TCP的AIMD（加性增窗、乘性减窗）策略

  ```c
  While(Sending_Not_Finish){
  	if(Not_Loss_Packet){
  		CongWin++;
  	}else
  		CongWin=[CongWin/2]; //[]的意思是取整
  }
  ```

  

# 可靠性传输-差错控制

* 检验和
  * 每个报文段有16位检验和，若检验和无效，则由终点TCP挂失报文。
* 确认   
  * 积累确认（ACK）
    *   接收方通告期望接收下一节点seqnum，忽略失序到达报文。
    * 在TCP首部的32位ACK字段用于积累确认，它的值仅在ACK标志为1时才有效
  * 选择确认（SACK`selective acknowledgment`）
    * SACK要报告失序的数据块及重复的报文段
  * 产生确认的情况
* 重传（差错控制核心）
  * 一个报文段发送时，会被保存到一个队列中，直至被确认为止
  * 重传计时器超时或发送方收到一报文段三个重复ACK，该报文段重传​
  * 类型
    * RTO重传（超时重传）
      * 发送方TCP计时器时间到，TCP发送队列最前面报文段（序列号最小），并重启计时器
      * RTO值是动态的，根据报文段的往返时间（RTT）更新
    * 三个重复的ACK报文段（快重传）
      * 若某报文段有3个重复确认，立即重传并重启RTO计时器，而不用等待计时器超时
* [ARQ协议](https://mp.weixin.qq.com/s/-DZj158-LOQmnCayf1_n3A)
  * 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
* 其它
  * TCP不会将失序到达报文段丢了，会暂时保存并标为失序，直至失序报文段到齐

# ICMP Internet控制[报文](https://baike.baidu.com/item/%E6%8A%A5%E6%96%87/3164352)协议

ICMP是（Internet Control Message Protocol）Internet控制[报文](https://baike.baidu.com/item/%E6%8A%A5%E6%96%87/3164352)协议。它是[TCP/IP协议簇](https://baike.baidu.com/item/TCP%2FIP%E5%8D%8F%E8%AE%AE%E7%B0%87)的一个子协议，用于在IP[主机](https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/455151)、[路由](https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1)器之间传递控制消息。控制消息是指[网络通](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%9A)不通、[主机](https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/455151)是否可达、[路由](https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1/363497)是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。

# 服务器常用端口及作用

* 21 FTP
* 23 TELNET
* 25 SMTP
* 80 HTTP
* 3306 MYSQL

# 网络编程中,需要调用哪些函数

* 客户端
  * connect() 连接服务器
  * send() 发送消息
  * close() 关闭socket
* 服务端
  * bind() 绑定端口
  * listen() 监听端口
  * accept() 接收连接
  * recv() 接收消息
  * close() 关闭socket

# [TCP/IP协议栈分几层](https://blog.csdn.net/Mary19920410/article/details/61931234)

![img](https://img-blog.csdn.net/20170313215505756)

* 应用层
  * FTP,SMTP HTTP
* 传输层
  * TCP UDP
* 网络层
  * ICMP IGMP
* 网络接口层(物理层+链路层)
  * ARP

# [TCP的拆包和粘包](https://zhuanlan.zhihu.com/p/77275039)

* 粘包
  * 在socket通讯过程中，如果通讯的一端一次性连续发送多条数据包，tcp协议会将多个数据包打包成一个tcp报文发送出去，这就是所谓的**粘包**

* 拆包

  * 如果通讯的一端发送的数据包超过一次tcp报文所能传输的最大值时，就会将一个数据包拆成多个最大tcp长度的tcp报文分开传输，这就叫做**拆包**。

  ![img](https://i.loli.net/2020/08/05/GUIOPAY2fJE4hNc.jpg)

## [总结出现粘包的原因](https://zhuanlan.zhihu.com/p/77275039)

1. **要发送的数据小于TCP发送缓冲区的大小**，TCP将多次写入缓冲区的数据一次发送出去；
2. 接收数据端的应用层**没有及时读取接收缓冲区中的数据**；
3. **数据发送过快，数据包堆积导致缓冲区积压多个数据后才一次性发送出去**(如果客户端每发送一条数据就睡眠一段时间就不会发生粘包)；

##  拆包

如果数据包太大，超过MSS的大小，就会被拆包成多个TCP报文分开传输。

## [TCP粘包/拆包解决策略](https://www.jianshu.com/p/8eb143c0a59a)

* **消息定长。**每个发送的数据包大小固定，比如100字节，不足100字节的用空格补充，接受方取数据的时候根据这个长度来读取数据
* **每次发送一个应用数据包前在前面加上四个字节的包长度值**，指明这个应用包的真实长度
* **消息末尾增加换行符来表示一条完整的消息**。接收方读取的时候根据换行符来判断是否是一条完整的消息。如果消息的内容也包含换行符，那么这种方式就不合适了。

* 将消息分为消息头和消息尾两部分，消息头指定数据长度，根据消息长度来读取完整的消息。例如UDP协议是这么设计的，用两个字节来表示消息长度，所以UDP不存在粘包和拆包问题。

![img](https://i.loli.net/2020/08/05/LhrVQvc5Psf1iqg.jpg)

