# 网络中的「动态路由算法」，你了解吗？

在计算机网络中，路由器的一个很重要责任就是要在端对端的节点中找出一条最佳路径出来，通过自己与相邻节点之间的信息，来计算出从自己位置到目的节点之间的最佳线路，这种算法我们可以理解为路由算法。

路由的模式又主要分为「静态路由」和「动态路由」。静态路由协议是由网络管理员手动输入配置的，适用于小型的不太复杂的网络环境中，或者有特定需求的网络场景中。而动态路由协议是现代计算机网络中最为常用的一种方式。动态路由算法能够根据网络拓扑结构去适应流量的变化。

动态路由算法大致可以分为两类：

- **距离矢量路由算法**
- **链路状态路由算法**

## 一、距离矢量路由算法

**距离矢量路由算法**（Distance Vector Routing），它是网络上最早使用的动态路由算法，也称为Bellman-Ford或者Ford-Fulkerson算法。基于这类算法实现的协议有：RIP、BGP等。

![https://img1.mukewang.com/5ba456d20001a7fb04490311.jpg](https://img.mukewang.com/5ba456d20001a7fb04490311.jpg)

如图，

 

这类算法的基本思路是：网络中每一个路由器都要维护一张 矢量表 ，这个 矢量表 中的每一行都记录了从当前位置能到达的目标路由器的最佳出口（接口）和距离（跳数）。

**每隔一段时间当前路由器会向所有的邻居节点发送自己的这个表，同时它也会接收每个邻居发来的它们的表。并会将邻居的表和自己的表做一个对比更新。**
比如当前 路由器X 离 邻居Y路由器 的距离是m，此时收到 邻居Y 发来的表中写到了“ 邻居Y离路由器Z的距离是n ”，那 当前路由器X 就知道它离 路由器Z 的距离可能就是 m+n 了，如图：

![https://img3.mukewang.com/5ba456e100014f6705180086.jpg](https://img4.mukewang.com/5ba456e100014f6705000084.jpg)

就这样继续类推，要不了多久，**每个路由器就可以将网络中所有路由节点和子网线路都汇聚起来了。这样的话，每个路由器只需要查找自己的表就可以很容易的知道到达目的地的最佳出口（接口）是哪个了。**

当然，当网络结构发生变化的时候，各个路由器中的矢量表也会随之动态更新。

好了，讲到这里，基本上对「距离矢量路由算法」大概原理有个认识了，现在我们再来仔细分析分析这个算法的名字，可以发现，它的名字取的还是蛮有意思的，非常贴切。“距离”这个词就基本表明了这个算法是通过 距离（跳数/时间）来度量2个路由网络之间的线路的，而“矢量”这个词，可以看出线路是有方向性的，且路由表中只记录了数据包去往目的地应该走哪个出口方向，并不会记录到达目的地的整条路径。

「距离矢量路由算法」的**优点**很明显：非常简单清晰，且任何加入到网络中的新节点都能很快的与其它节点建立起联系获得补充信息。

**缺点**呢，首先就是每次发送信息的时候，要发送整个全局路由表，太大了，因为每个路由器需要在矢量表中记录下整个网络的信息，导致需要较大存储、CPU、网络开销，对资源的要求越来越高。还有一个问题就是收敛时间太慢，也就是路由器共享路由信息并使各台路由器掌握的网络情况达到一致所需的时间比较久，收敛速度慢会导致有些路由器的表更新慢，从而造成路由环路的问题。

### 路由信息协议(RIP)

路由信息协议RIP（Routing Information Protocol）是基于[距离矢量](https://baike.baidu.com/item/%E8%B7%9D%E7%A6%BB%E7%9F%A2%E9%87%8F)算法的[路由协议](https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/202634)，利用跳数来作为计量标准。

* 简介

路由信息协议RIP（Routing Information Protocol）是基于距离矢量算法的路由协议，利用跳数来作为计量标准。在带宽、配置和管理方面要求较低，主要适合于规模较小的网络中。

* 工作原理

(1)路由建立

路由器运行RIP后，会首先发送路由更新请求，收到请求的路由器会发送自己的RIP路由进行响应；网络稳定后，路由器会周期性发送路由更新信息。

(2)距离矢量的计算

RIP度量的单位是跳数，其单位是1，也就是规定每一条链路的成本为1，而不考虑链路的实际带宽、时延等因素，RIP最多允许15跳。

RIP利用度量来表示它和所有已知目的地间的距离。

当一个RIP更新报文到达时，接收方路由器和自己的RIP路由表中的每一项进行比较，并按照距离矢量路由算法对自己的RIP路由表进行修正。

(3)定时器

周期更新定时器：用来激发RIP路由器路由表的更新，每个RIP节点只有一个更新定时器，设为30s。每隔30s路由器会向其邻居广播自己的路由表信息。每个RIP路由器的定时器都独立于网络中其他路由器，因此它们同时广播的可能性很小。

超时定时器：用来判定某条路由是否可用。每条路由有一个超时定时器，设为180s。当一条路由激活或更新时，该定时器初始化，如果在180s之内没有收到关于那条路由的更新，则将该路由置为无效。

清除定时器：用来判定是否清除一条路由。每条路由有一个清除定时器，设为120s。当路由器认识到某条路由无效时，就初始化一个清除定时器，如果在120s内还没收到这条路由的更新，就从路由表中将该路由删除。

延迟定时器：为避免触发更新引起广播风暴而设置的一个随机的延迟定时器，延迟时间为1～5s。

(4)环路

当网络发生故障时，RIP网络有可能产生路由环路。可以通过水平分割、毒性反转、触发更新、抑制时间等技术来避免环路的产生。

## 二、链路状态路由算法

**链路状态路由算法**（Link State Routing ），基于Dijkstra算法，它是以图论作为理论基础，用图来表示网络拓扑结构，用图论中的最短路径算法来计算网络间的最佳路由。基于这类算法实现的协议有：OSPF 等。
如图，

![https://img.mukewang.com/5ba456ee00011a3205650357.jpg](https://img1.mukewang.com/5ba456ee00011a3205000316.jpg)

这类算法的基本思路是：采用的是不停的拼接地图的方式。每一个路由器首先都会发现自己身边的邻居节点，然后将自己与邻居节点之间的链路状态包广播出去，发送到整个网络。这样，当某个路由器收到从网络中其它路由器广播来的路由信息包（链路状态包）之后，会将这个包中的信息与自己路由器上的信息进行拼装，最终形成一个全网的拓扑视图。

当路由器中形成了全网的拓扑视图后，它就可以通过最短路径算法来计算当前节点到其它路由器之间的最短路径了。当某台路由器的链路状态发生变化时，路由器采用**洪泛法**向所有路由器发送此信息，其它路由器使用收到的信息重新计算最佳路径，重新生成路由表（拓扑图）。

**这里可以做一个类比，有一个路人甲人去问路，然后本地人A只知道A自己生活方圆5公里的地图，本地人B只知道B自己生活的方圆5公里的地图，但是路人甲要去的地方需要穿过A和B所在区域，那么就把A和B的2份地图拿来拼装在一起，然后去往目的地的完整路线就可以查出来了。**

链路状态路由算法简单而言就是五个步骤：

1. 发现邻居节点，并了解邻居网络地址
2. 测量到邻居节点的距离或成本度量值
3. 构建一个包含自己所拥有信息的链路状态包
4. 将这个包广播到网络中，并接收其它路由器的链路状态包
5. 计算出当前节点到其它节点之间的最短路径（基于Dijkstra算法）

 ![https://img1.mukewang.com/5ba456f800011da407000185.jpg](https://img.mukewang.com/5ba456f800011da405000133.jpg)

# 组播相关协议

多播路由的一种常见的思路就是在多播组成员之间构造一棵扩展分布树。在一个特定的“发送源，目的组”对上的IP多播路由协议流量都是通过这个扩展树从发送源传输到接受者的，这个扩展树连接了该多播组中所有主机。不同的IP多播[路由协议](http://network.51cto.com/art/200511/11236.htm)使用不同的技术来构造这些多播扩展树，一旦这个树构造完成，所有的多播流量都将通过它来传播。

总的说来IP多播路由协议可以分为以下两种基本类型。第一种假设多播组成员密集地分布在网络中，也就是说，网络大多数的子网都至少包含一个多播组成员，而且网络带宽足够大，这种被称作“**密集模式**”（Dense-Mode）的多播路由协议**依赖于广播技术来将数据“推”向网络中所有的路由器**。密集模式IP多播路由协议包括距离向量IP多播路由协议（DVMRP：Distance Vector Multicast Routing Protocol）、多播开放最短路径优先协议（MOSPF：Multicast Open Shortest Path First）和密集模式独立多播协议（PIM-DM：Protocol-Independent Multicast-Dense Mode）等。

多播路由的第二种类型则假设多播组成员在网络中是稀疏分散的，并且网络不能提供足够的传输带宽，比如Internet上通过**ISDN**线路连接分散在许多不同地区的大量用户。在这种情况下，广播就会浪费许多不必要的网络带宽从而可能导致严重的网络性能问题。于是**稀疏模式IP多播路由协议必须依赖于具有路由选择能力的技术来建立和维持多播树**。稀疏模式主要有基于核心树的多播协议（CBT：Core Based Tree）和稀疏模式独立协议多播（PIM-SM：Protocol-Independent Multicast-Sparse Mode）。

## 密集模式协议

### （1）距离向量IP多播路由协议 （DVMRP）

第一个支持多播功能的路由协议就是距离向量IP多播路由协议。它已经被广泛地应用在多播骨干网MBONE上。**DVMRP为每个发送源和目的主机组构建不同的分布树。每个分布树都是一个以多播发送源作为根，以多播接受目的主机作为叶的最小扩展分布树**。这个分布树为发送源和组中每个多播接受者之间提供了一个最短路径，这个以“跳数”为单位的最短路径就是DVMRP的量度。当一个发送源要向多播组中发送消息时，一个扩展分布树就根据这个请求而建立，并且使用“广播和修剪”的技术来维持这个扩展分布树。

扩展分布树构建过程中的选择性发送多播包的具体运作是：当一个路由器接收到一个多播包，它先检查它的单播路由表来查找到多播组发送源的最短路径的接口，如果这个接口就是这个多播包到达的接口，那么路由器就将这个多播组信息记录到它的内部路由表（指明该组数据包应该发送的接口），并且将这个多播包向除了接受到该数据包的路由器以外的其他临近路由器继续发送。如果这个多播包的到达接口不是该路由器到发送源的最短路径的接口，那么这个包就被丢弃。这种机制被称为“反向路径广播”（Reverse-Path Broadcasting）机制，保证了构建的树中不会出现环，而且从发送源到所有接受者都是最短路径。对子网中密集分布的多播组来说DVMRP能够很好的运作，但是**对于在范围比较大的区域上分散分布的多播组来说，周期性的广播行为会导致严重的性能问题。DVMRP不能支持大型网络中稀疏分散的多播组**。

### （2）多播开放最短路径优先 （MOSPF）

开放最短路径优先（OSPF）是一个IP多播路由协议，它将数据包在最小开销路径上进行路由传送，这里的开销是表示链路状态的一种量度。除了路径中的跳数以外，其他能够影响路径开销的网络性能参数还有负载平衡信息、应用程序需要的QoS等。**MOSPF是为单播路由多播使用设计的**。MOSPF依赖于OSPF作为单播路由协议，就象DVMRP也包含它自己的单播协议一样。**在一个OSPF/MOSPF网络中每个路由器都维持一个最新的全网络拓扑结构图。这个“链路状态”信息被用来构建多播分布树。**

每个MOSPF路由器都通过IGMP协议周期性的收集多播组成员关系信息。这些信息和这些链路状态信息被发送到其路由域中的所有其他路由器。路由器将根据它们从临近路由器接收到的这些信息更新他们的内部连接状态信息。**由于每个路由器都清楚整个网络的拓扑结构，就能够独立的计算出一个最小开销扩展树，将多播发送源和多播组成员分别作为树的根和叶。这个树就是用来将多播流从发送源发送到多播组成员的路径。**

### （3）独立多播密集模式协议（PIM-DM）

独立多播协议（PIM）是一种标准的IP多播路由协议，并能够在Internet上提供可扩展的域间多播路由而不依赖于任何单播协议。PIM有两种运行模式，一种是密集分布多播组模式，另一个是稀疏分布多播组模式，前者被称为独立多播密集模式协议（PIM-DM），后者被称为独立多播稀疏模式协议（PIM-SM）。PIM-DM有点类似于DVMRP，这两个协议都使用了反向路径多播机制来构建分布树。它们之间的主要不同在于PIM完全不依赖于网络中的单播路由协议而DVMRP依赖于某个相关的单播路由协议机制，并且PIM-DM比DVMRP简单。

PIM-DM协议和所有的密集模式IP多播路由协议一样也是**数据驱动**的。但是既然PIM-DM不依赖于任何单播路由协议，路由器某个接收端口（就是返回到源的最短路径的端口）接收到的多播数据包被发送到所有下行接口直到不需要的分枝从树中被修剪掉。DVMRP在树构建阶段能够使用单播协议提供的拓扑数据有选择性的向下行发送数据包，PIM-DM则更加倾向于简单性和独立性，甚至不惜增加数据包复制引起的额外开销。

## 稀疏模式多播路由协议

当多播组在网络中集中分布或者网络提供足够大带宽的情况下，密集模式IP多播路由协议是一个有效的方法，当多播组成员在广泛区域内稀疏分布时，就需要另一种方法即稀疏模式IP多播路由协议将多播流量控制在连接到多播组成员的链路路径上，而不会“泄漏”到不相关的链路路径上，这样既保证了数据传输的安全，又能够有效的控制网络中的总流量和路由器的负载。

### （1）基于核心树的多播协议 （CBT）

和DVMRP和MOSPF为每个“发送源、目的组”对构建最短路径树不同的是，**CBT协议只构建一个树给组中所有成员共享，这个树也就被称为共享树**。**整个多播组的多播通信量都在这个共享树上进行收发而不论发送源有多少或者在什么位置。这种共享树的使用能够极大的减少路由器中的多播状态信息。**

**CBT共享树有一个核心路由器用来构建这个树。要加入的路由器发送加入请求给这个核心路由器。核心路由器接收到加入请求后，沿反路径返回一个确认，这样就构成了树的一个分枝。**加入请求数据包在被确认之前不需要一直被传送到核心路由器。**如果加入请求包在到达核心路由器之前先到达树上的某个路由器，该路由器就接收下这个请求包而不继续向前发送并确认这个请求包。发送请求的路由器就连接到共享树上了**。 CBT将多播流量集中在最少数量的链路而不是在一个基于发送源的共享树上。集中在核心路由器上的流量可能会引起多播路由的某些问题。某些版本的CBT支持多个多播核心的使用，和单个多播核心相比多核心更能达到负载平衡。

### （2）独立多播稀疏模式协议 （PIM-SM）

和CBT相似，PIM-SM被设计成将多播限制在需要收发的路由器上。PIM-SM围绕一个被称为集中点（RP：Rendezvous Point）的IP多播路由协议构建多播分布树。这个集中点扮演着和CBT核心路由器相同的角色，接收者在集中点能查找到新的发送源。但是PIM-SM比CBT更灵活，CBT的树通常是多播组共享树，PIM-SM中的独立的接收者可以选择是构建组共享树还是最短路径树。PIM-SM协议最初先为多播组构建一个组共享树。这个树由连接到集中点的发送者和接收者共同构建，就像CBT协议围绕着核心路由器构建的共享树一样。这共享树建立以后，一个接受者（实际上是最接近这个接收者的路由器）可以选择通过最短路径树改变到发送源的连接。这个操作的过程是通过向发送源发送一个PIM加入请求完成的。一旦从发送源到接收者的最短路径建立了，通过RP的外部分枝就被修剪掉了。

 